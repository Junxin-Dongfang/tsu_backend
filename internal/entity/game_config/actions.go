// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package game_config

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Action is an object representing the database table.
type Action struct {
	ID               string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	ActionCode       string            `boil:"action_code" json:"action_code" toml:"action_code" yaml:"action_code"`
	ActionName       string            `boil:"action_name" json:"action_name" toml:"action_name" yaml:"action_name"`
	ActionCategoryID null.String       `boil:"action_category_id" json:"action_category_id,omitempty" toml:"action_category_id" yaml:"action_category_id,omitempty"`
	ActionType       string            `boil:"action_type" json:"action_type" toml:"action_type" yaml:"action_type"`
	RelatedSkillID   null.String       `boil:"related_skill_id" json:"related_skill_id,omitempty" toml:"related_skill_id" yaml:"related_skill_id,omitempty"`
	FeatureTags      types.StringArray `boil:"feature_tags" json:"feature_tags,omitempty" toml:"feature_tags" yaml:"feature_tags,omitempty"`
	RangeConfig      types.JSON        `boil:"range_config" json:"range_config" toml:"range_config" yaml:"range_config"`
	TargetConfig     null.JSON         `boil:"target_config" json:"target_config,omitempty" toml:"target_config" yaml:"target_config,omitempty"`
	AreaConfig       null.JSON         `boil:"area_config" json:"area_config,omitempty" toml:"area_config" yaml:"area_config,omitempty"`
	ActionPointCost  null.Int          `boil:"action_point_cost" json:"action_point_cost,omitempty" toml:"action_point_cost" yaml:"action_point_cost,omitempty"`
	ManaCost         null.Int          `boil:"mana_cost" json:"mana_cost,omitempty" toml:"mana_cost" yaml:"mana_cost,omitempty"`
	// MP消耗公式（如"50+2*skill_level"），优先于mana_cost
	ManaCostFormula null.String `boil:"mana_cost_formula" json:"mana_cost_formula,omitempty" toml:"mana_cost_formula" yaml:"mana_cost_formula,omitempty"`
	CooldownTurns   null.Int    `boil:"cooldown_turns" json:"cooldown_turns,omitempty" toml:"cooldown_turns" yaml:"cooldown_turns,omitempty"`
	UsesPerBattle   null.Int    `boil:"uses_per_battle" json:"uses_per_battle,omitempty" toml:"uses_per_battle" yaml:"uses_per_battle,omitempty"`
	// 命中率计算配置
	HitRateConfig null.JSON `boil:"hit_rate_config" json:"hit_rate_config,omitempty" toml:"hit_rate_config" yaml:"hit_rate_config,omitempty"`
	// Excel原始效果配置（用于兼容导入）
	LegacyEffectConfig null.JSON `boil:"legacy_effect_config" json:"legacy_effect_config,omitempty" toml:"legacy_effect_config" yaml:"legacy_effect_config,omitempty"`
	Requirements       null.JSON `boil:"requirements" json:"requirements,omitempty" toml:"requirements" yaml:"requirements,omitempty"`
	// 开始标记数组（如STARTING_ATTACK_ACTION）
	StartFlags      types.StringArray `boil:"start_flags" json:"start_flags,omitempty" toml:"start_flags" yaml:"start_flags,omitempty"`
	AnimationConfig null.JSON         `boil:"animation_config" json:"animation_config,omitempty" toml:"animation_config" yaml:"animation_config,omitempty"`
	VisualEffects   null.JSON         `boil:"visual_effects" json:"visual_effects,omitempty" toml:"visual_effects" yaml:"visual_effects,omitempty"`
	SoundEffects    null.JSON         `boil:"sound_effects" json:"sound_effects,omitempty" toml:"sound_effects" yaml:"sound_effects,omitempty"`
	Description     null.String       `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	IsActive        null.Bool         `boil:"is_active" json:"is_active,omitempty" toml:"is_active" yaml:"is_active,omitempty"`
	CreatedAt       null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt       null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt       null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *actionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L actionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ActionColumns = struct {
	ID                 string
	ActionCode         string
	ActionName         string
	ActionCategoryID   string
	ActionType         string
	RelatedSkillID     string
	FeatureTags        string
	RangeConfig        string
	TargetConfig       string
	AreaConfig         string
	ActionPointCost    string
	ManaCost           string
	ManaCostFormula    string
	CooldownTurns      string
	UsesPerBattle      string
	HitRateConfig      string
	LegacyEffectConfig string
	Requirements       string
	StartFlags         string
	AnimationConfig    string
	VisualEffects      string
	SoundEffects       string
	Description        string
	IsActive           string
	CreatedAt          string
	UpdatedAt          string
	DeletedAt          string
}{
	ID:                 "id",
	ActionCode:         "action_code",
	ActionName:         "action_name",
	ActionCategoryID:   "action_category_id",
	ActionType:         "action_type",
	RelatedSkillID:     "related_skill_id",
	FeatureTags:        "feature_tags",
	RangeConfig:        "range_config",
	TargetConfig:       "target_config",
	AreaConfig:         "area_config",
	ActionPointCost:    "action_point_cost",
	ManaCost:           "mana_cost",
	ManaCostFormula:    "mana_cost_formula",
	CooldownTurns:      "cooldown_turns",
	UsesPerBattle:      "uses_per_battle",
	HitRateConfig:      "hit_rate_config",
	LegacyEffectConfig: "legacy_effect_config",
	Requirements:       "requirements",
	StartFlags:         "start_flags",
	AnimationConfig:    "animation_config",
	VisualEffects:      "visual_effects",
	SoundEffects:       "sound_effects",
	Description:        "description",
	IsActive:           "is_active",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
	DeletedAt:          "deleted_at",
}

var ActionTableColumns = struct {
	ID                 string
	ActionCode         string
	ActionName         string
	ActionCategoryID   string
	ActionType         string
	RelatedSkillID     string
	FeatureTags        string
	RangeConfig        string
	TargetConfig       string
	AreaConfig         string
	ActionPointCost    string
	ManaCost           string
	ManaCostFormula    string
	CooldownTurns      string
	UsesPerBattle      string
	HitRateConfig      string
	LegacyEffectConfig string
	Requirements       string
	StartFlags         string
	AnimationConfig    string
	VisualEffects      string
	SoundEffects       string
	Description        string
	IsActive           string
	CreatedAt          string
	UpdatedAt          string
	DeletedAt          string
}{
	ID:                 "actions.id",
	ActionCode:         "actions.action_code",
	ActionName:         "actions.action_name",
	ActionCategoryID:   "actions.action_category_id",
	ActionType:         "actions.action_type",
	RelatedSkillID:     "actions.related_skill_id",
	FeatureTags:        "actions.feature_tags",
	RangeConfig:        "actions.range_config",
	TargetConfig:       "actions.target_config",
	AreaConfig:         "actions.area_config",
	ActionPointCost:    "actions.action_point_cost",
	ManaCost:           "actions.mana_cost",
	ManaCostFormula:    "actions.mana_cost_formula",
	CooldownTurns:      "actions.cooldown_turns",
	UsesPerBattle:      "actions.uses_per_battle",
	HitRateConfig:      "actions.hit_rate_config",
	LegacyEffectConfig: "actions.legacy_effect_config",
	Requirements:       "actions.requirements",
	StartFlags:         "actions.start_flags",
	AnimationConfig:    "actions.animation_config",
	VisualEffects:      "actions.visual_effects",
	SoundEffects:       "actions.sound_effects",
	Description:        "actions.description",
	IsActive:           "actions.is_active",
	CreatedAt:          "actions.created_at",
	UpdatedAt:          "actions.updated_at",
	DeletedAt:          "actions.deleted_at",
}

// Generated where

type whereHelpertypes_JSON struct{ field string }

func (w whereHelpertypes_JSON) EQ(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_JSON) NEQ(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_JSON) LT(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_JSON) LTE(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_JSON) GT(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_JSON) GTE(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var ActionWhere = struct {
	ID                 whereHelperstring
	ActionCode         whereHelperstring
	ActionName         whereHelperstring
	ActionCategoryID   whereHelpernull_String
	ActionType         whereHelperstring
	RelatedSkillID     whereHelpernull_String
	FeatureTags        whereHelpertypes_StringArray
	RangeConfig        whereHelpertypes_JSON
	TargetConfig       whereHelpernull_JSON
	AreaConfig         whereHelpernull_JSON
	ActionPointCost    whereHelpernull_Int
	ManaCost           whereHelpernull_Int
	ManaCostFormula    whereHelpernull_String
	CooldownTurns      whereHelpernull_Int
	UsesPerBattle      whereHelpernull_Int
	HitRateConfig      whereHelpernull_JSON
	LegacyEffectConfig whereHelpernull_JSON
	Requirements       whereHelpernull_JSON
	StartFlags         whereHelpertypes_StringArray
	AnimationConfig    whereHelpernull_JSON
	VisualEffects      whereHelpernull_JSON
	SoundEffects       whereHelpernull_JSON
	Description        whereHelpernull_String
	IsActive           whereHelpernull_Bool
	CreatedAt          whereHelpernull_Time
	UpdatedAt          whereHelpernull_Time
	DeletedAt          whereHelpernull_Time
}{
	ID:                 whereHelperstring{field: "\"game_config\".\"actions\".\"id\""},
	ActionCode:         whereHelperstring{field: "\"game_config\".\"actions\".\"action_code\""},
	ActionName:         whereHelperstring{field: "\"game_config\".\"actions\".\"action_name\""},
	ActionCategoryID:   whereHelpernull_String{field: "\"game_config\".\"actions\".\"action_category_id\""},
	ActionType:         whereHelperstring{field: "\"game_config\".\"actions\".\"action_type\""},
	RelatedSkillID:     whereHelpernull_String{field: "\"game_config\".\"actions\".\"related_skill_id\""},
	FeatureTags:        whereHelpertypes_StringArray{field: "\"game_config\".\"actions\".\"feature_tags\""},
	RangeConfig:        whereHelpertypes_JSON{field: "\"game_config\".\"actions\".\"range_config\""},
	TargetConfig:       whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"target_config\""},
	AreaConfig:         whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"area_config\""},
	ActionPointCost:    whereHelpernull_Int{field: "\"game_config\".\"actions\".\"action_point_cost\""},
	ManaCost:           whereHelpernull_Int{field: "\"game_config\".\"actions\".\"mana_cost\""},
	ManaCostFormula:    whereHelpernull_String{field: "\"game_config\".\"actions\".\"mana_cost_formula\""},
	CooldownTurns:      whereHelpernull_Int{field: "\"game_config\".\"actions\".\"cooldown_turns\""},
	UsesPerBattle:      whereHelpernull_Int{field: "\"game_config\".\"actions\".\"uses_per_battle\""},
	HitRateConfig:      whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"hit_rate_config\""},
	LegacyEffectConfig: whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"legacy_effect_config\""},
	Requirements:       whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"requirements\""},
	StartFlags:         whereHelpertypes_StringArray{field: "\"game_config\".\"actions\".\"start_flags\""},
	AnimationConfig:    whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"animation_config\""},
	VisualEffects:      whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"visual_effects\""},
	SoundEffects:       whereHelpernull_JSON{field: "\"game_config\".\"actions\".\"sound_effects\""},
	Description:        whereHelpernull_String{field: "\"game_config\".\"actions\".\"description\""},
	IsActive:           whereHelpernull_Bool{field: "\"game_config\".\"actions\".\"is_active\""},
	CreatedAt:          whereHelpernull_Time{field: "\"game_config\".\"actions\".\"created_at\""},
	UpdatedAt:          whereHelpernull_Time{field: "\"game_config\".\"actions\".\"updated_at\""},
	DeletedAt:          whereHelpernull_Time{field: "\"game_config\".\"actions\".\"deleted_at\""},
}

// ActionRels is where relationship names are stored.
var ActionRels = struct {
	ActionCategory     string
	RelatedSkill       string
	ActionEffects      string
	SkillUnlockActions string
}{
	ActionCategory:     "ActionCategory",
	RelatedSkill:       "RelatedSkill",
	ActionEffects:      "ActionEffects",
	SkillUnlockActions: "SkillUnlockActions",
}

// actionR is where relationships are stored.
type actionR struct {
	ActionCategory     *ActionCategory        `boil:"ActionCategory" json:"ActionCategory" toml:"ActionCategory" yaml:"ActionCategory"`
	RelatedSkill       *Skill                 `boil:"RelatedSkill" json:"RelatedSkill" toml:"RelatedSkill" yaml:"RelatedSkill"`
	ActionEffects      ActionEffectSlice      `boil:"ActionEffects" json:"ActionEffects" toml:"ActionEffects" yaml:"ActionEffects"`
	SkillUnlockActions SkillUnlockActionSlice `boil:"SkillUnlockActions" json:"SkillUnlockActions" toml:"SkillUnlockActions" yaml:"SkillUnlockActions"`
}

// NewStruct creates a new relationship struct
func (*actionR) NewStruct() *actionR {
	return &actionR{}
}

func (o *Action) GetActionCategory() *ActionCategory {
	if o == nil {
		return nil
	}

	return o.R.GetActionCategory()
}

func (r *actionR) GetActionCategory() *ActionCategory {
	if r == nil {
		return nil
	}

	return r.ActionCategory
}

func (o *Action) GetRelatedSkill() *Skill {
	if o == nil {
		return nil
	}

	return o.R.GetRelatedSkill()
}

func (r *actionR) GetRelatedSkill() *Skill {
	if r == nil {
		return nil
	}

	return r.RelatedSkill
}

func (o *Action) GetActionEffects() ActionEffectSlice {
	if o == nil {
		return nil
	}

	return o.R.GetActionEffects()
}

func (r *actionR) GetActionEffects() ActionEffectSlice {
	if r == nil {
		return nil
	}

	return r.ActionEffects
}

func (o *Action) GetSkillUnlockActions() SkillUnlockActionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetSkillUnlockActions()
}

func (r *actionR) GetSkillUnlockActions() SkillUnlockActionSlice {
	if r == nil {
		return nil
	}

	return r.SkillUnlockActions
}

// actionL is where Load methods for each relationship are stored.
type actionL struct{}

var (
	actionAllColumns            = []string{"id", "action_code", "action_name", "action_category_id", "action_type", "related_skill_id", "feature_tags", "range_config", "target_config", "area_config", "action_point_cost", "mana_cost", "mana_cost_formula", "cooldown_turns", "uses_per_battle", "hit_rate_config", "legacy_effect_config", "requirements", "start_flags", "animation_config", "visual_effects", "sound_effects", "description", "is_active", "created_at", "updated_at", "deleted_at"}
	actionColumnsWithoutDefault = []string{"action_code", "action_name"}
	actionColumnsWithDefault    = []string{"id", "action_category_id", "action_type", "related_skill_id", "feature_tags", "range_config", "target_config", "area_config", "action_point_cost", "mana_cost", "mana_cost_formula", "cooldown_turns", "uses_per_battle", "hit_rate_config", "legacy_effect_config", "requirements", "start_flags", "animation_config", "visual_effects", "sound_effects", "description", "is_active", "created_at", "updated_at", "deleted_at"}
	actionPrimaryKeyColumns     = []string{"id"}
	actionGeneratedColumns      = []string{}
)

type (
	// ActionSlice is an alias for a slice of pointers to Action.
	// This should almost always be used instead of []Action.
	ActionSlice []*Action
	// ActionHook is the signature for custom Action hook methods
	ActionHook func(context.Context, boil.ContextExecutor, *Action) error

	actionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	actionType                 = reflect.TypeOf(&Action{})
	actionMapping              = queries.MakeStructMapping(actionType)
	actionPrimaryKeyMapping, _ = queries.BindMapping(actionType, actionMapping, actionPrimaryKeyColumns)
	actionInsertCacheMut       sync.RWMutex
	actionInsertCache          = make(map[string]insertCache)
	actionUpdateCacheMut       sync.RWMutex
	actionUpdateCache          = make(map[string]updateCache)
	actionUpsertCacheMut       sync.RWMutex
	actionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var actionAfterSelectMu sync.Mutex
var actionAfterSelectHooks []ActionHook

var actionBeforeInsertMu sync.Mutex
var actionBeforeInsertHooks []ActionHook
var actionAfterInsertMu sync.Mutex
var actionAfterInsertHooks []ActionHook

var actionBeforeUpdateMu sync.Mutex
var actionBeforeUpdateHooks []ActionHook
var actionAfterUpdateMu sync.Mutex
var actionAfterUpdateHooks []ActionHook

var actionBeforeDeleteMu sync.Mutex
var actionBeforeDeleteHooks []ActionHook
var actionAfterDeleteMu sync.Mutex
var actionAfterDeleteHooks []ActionHook

var actionBeforeUpsertMu sync.Mutex
var actionBeforeUpsertHooks []ActionHook
var actionAfterUpsertMu sync.Mutex
var actionAfterUpsertHooks []ActionHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Action) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Action) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Action) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Action) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Action) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Action) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Action) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Action) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Action) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range actionAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddActionHook registers your hook function for all future operations.
func AddActionHook(hookPoint boil.HookPoint, actionHook ActionHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		actionAfterSelectMu.Lock()
		actionAfterSelectHooks = append(actionAfterSelectHooks, actionHook)
		actionAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		actionBeforeInsertMu.Lock()
		actionBeforeInsertHooks = append(actionBeforeInsertHooks, actionHook)
		actionBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		actionAfterInsertMu.Lock()
		actionAfterInsertHooks = append(actionAfterInsertHooks, actionHook)
		actionAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		actionBeforeUpdateMu.Lock()
		actionBeforeUpdateHooks = append(actionBeforeUpdateHooks, actionHook)
		actionBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		actionAfterUpdateMu.Lock()
		actionAfterUpdateHooks = append(actionAfterUpdateHooks, actionHook)
		actionAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		actionBeforeDeleteMu.Lock()
		actionBeforeDeleteHooks = append(actionBeforeDeleteHooks, actionHook)
		actionBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		actionAfterDeleteMu.Lock()
		actionAfterDeleteHooks = append(actionAfterDeleteHooks, actionHook)
		actionAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		actionBeforeUpsertMu.Lock()
		actionBeforeUpsertHooks = append(actionBeforeUpsertHooks, actionHook)
		actionBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		actionAfterUpsertMu.Lock()
		actionAfterUpsertHooks = append(actionAfterUpsertHooks, actionHook)
		actionAfterUpsertMu.Unlock()
	}
}

// OneG returns a single action record from the query using the global executor.
func (q actionQuery) OneG(ctx context.Context) (*Action, error) {
	return q.One(ctx, boil.GetContextDB())
}

// OneGP returns a single action record from the query using the global executor, and panics on error.
func (q actionQuery) OneGP(ctx context.Context) *Action {
	o, err := q.One(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single action record from the query, and panics on error.
func (q actionQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *Action {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single action record from the query.
func (q actionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Action, error) {
	o := &Action{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: failed to execute a one query for actions")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Action records from the query using the global executor.
func (q actionQuery) AllG(ctx context.Context) (ActionSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// AllGP returns all Action records from the query using the global executor, and panics on error.
func (q actionQuery) AllGP(ctx context.Context) ActionSlice {
	o, err := q.All(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all Action records from the query, and panics on error.
func (q actionQuery) AllP(ctx context.Context, exec boil.ContextExecutor) ActionSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all Action records from the query.
func (q actionQuery) All(ctx context.Context, exec boil.ContextExecutor) (ActionSlice, error) {
	var o []*Action

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "game_config: failed to assign all query results to Action slice")
	}

	if len(actionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Action records in the query using the global executor
func (q actionQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// CountGP returns the count of all Action records in the query using the global executor, and panics on error.
func (q actionQuery) CountGP(ctx context.Context) int64 {
	c, err := q.Count(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all Action records in the query, and panics on error.
func (q actionQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all Action records in the query.
func (q actionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to count actions rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q actionQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q actionQuery) ExistsGP(ctx context.Context) bool {
	e, err := q.Exists(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q actionQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q actionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "game_config: failed to check if actions exists")
	}

	return count > 0, nil
}

// ActionCategory pointed to by the foreign key.
func (o *Action) ActionCategory(mods ...qm.QueryMod) actionCategoryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ActionCategoryID),
	}

	queryMods = append(queryMods, mods...)

	return ActionCategories(queryMods...)
}

// RelatedSkill pointed to by the foreign key.
func (o *Action) RelatedSkill(mods ...qm.QueryMod) skillQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RelatedSkillID),
	}

	queryMods = append(queryMods, mods...)

	return Skills(queryMods...)
}

// ActionEffects retrieves all the action_effect's ActionEffects with an executor.
func (o *Action) ActionEffects(mods ...qm.QueryMod) actionEffectQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"action_effects\".\"action_id\"=?", o.ID),
	)

	return ActionEffects(queryMods...)
}

// SkillUnlockActions retrieves all the skill_unlock_action's SkillUnlockActions with an executor.
func (o *Action) SkillUnlockActions(mods ...qm.QueryMod) skillUnlockActionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"skill_unlock_actions\".\"action_id\"=?", o.ID),
	)

	return SkillUnlockActions(queryMods...)
}

// LoadActionCategory allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (actionL) LoadActionCategory(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAction interface{}, mods queries.Applicator) error {
	var slice []*Action
	var object *Action

	if singular {
		var ok bool
		object, ok = maybeAction.(*Action)
		if !ok {
			object = new(Action)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAction))
			}
		}
	} else {
		s, ok := maybeAction.(*[]*Action)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAction))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &actionR{}
		}
		if !queries.IsNil(object.ActionCategoryID) {
			args[object.ActionCategoryID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &actionR{}
			}

			if !queries.IsNil(obj.ActionCategoryID) {
				args[obj.ActionCategoryID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.action_categories`),
		qm.WhereIn(`game_config.action_categories.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.action_categories.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ActionCategory")
	}

	var resultSlice []*ActionCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ActionCategory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for action_categories")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for action_categories")
	}

	if len(actionCategoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ActionCategory = foreign
		if foreign.R == nil {
			foreign.R = &actionCategoryR{}
		}
		foreign.R.Actions = append(foreign.R.Actions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ActionCategoryID, foreign.ID) {
				local.R.ActionCategory = foreign
				if foreign.R == nil {
					foreign.R = &actionCategoryR{}
				}
				foreign.R.Actions = append(foreign.R.Actions, local)
				break
			}
		}
	}

	return nil
}

// LoadRelatedSkill allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (actionL) LoadRelatedSkill(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAction interface{}, mods queries.Applicator) error {
	var slice []*Action
	var object *Action

	if singular {
		var ok bool
		object, ok = maybeAction.(*Action)
		if !ok {
			object = new(Action)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAction))
			}
		}
	} else {
		s, ok := maybeAction.(*[]*Action)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAction))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &actionR{}
		}
		if !queries.IsNil(object.RelatedSkillID) {
			args[object.RelatedSkillID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &actionR{}
			}

			if !queries.IsNil(obj.RelatedSkillID) {
				args[obj.RelatedSkillID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.skills`),
		qm.WhereIn(`game_config.skills.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.skills.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Skill")
	}

	var resultSlice []*Skill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Skill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for skills")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for skills")
	}

	if len(skillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.RelatedSkill = foreign
		if foreign.R == nil {
			foreign.R = &skillR{}
		}
		foreign.R.RelatedSkillActions = append(foreign.R.RelatedSkillActions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.RelatedSkillID, foreign.ID) {
				local.R.RelatedSkill = foreign
				if foreign.R == nil {
					foreign.R = &skillR{}
				}
				foreign.R.RelatedSkillActions = append(foreign.R.RelatedSkillActions, local)
				break
			}
		}
	}

	return nil
}

// LoadActionEffects allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (actionL) LoadActionEffects(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAction interface{}, mods queries.Applicator) error {
	var slice []*Action
	var object *Action

	if singular {
		var ok bool
		object, ok = maybeAction.(*Action)
		if !ok {
			object = new(Action)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAction))
			}
		}
	} else {
		s, ok := maybeAction.(*[]*Action)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAction))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &actionR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &actionR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.action_effects`),
		qm.WhereIn(`game_config.action_effects.action_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.action_effects.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load action_effects")
	}

	var resultSlice []*ActionEffect
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice action_effects")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on action_effects")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for action_effects")
	}

	if len(actionEffectAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ActionEffects = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &actionEffectR{}
			}
			foreign.R.Action = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ActionID {
				local.R.ActionEffects = append(local.R.ActionEffects, foreign)
				if foreign.R == nil {
					foreign.R = &actionEffectR{}
				}
				foreign.R.Action = local
				break
			}
		}
	}

	return nil
}

// LoadSkillUnlockActions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (actionL) LoadSkillUnlockActions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAction interface{}, mods queries.Applicator) error {
	var slice []*Action
	var object *Action

	if singular {
		var ok bool
		object, ok = maybeAction.(*Action)
		if !ok {
			object = new(Action)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAction))
			}
		}
	} else {
		s, ok := maybeAction.(*[]*Action)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAction))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &actionR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &actionR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.skill_unlock_actions`),
		qm.WhereIn(`game_config.skill_unlock_actions.action_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.skill_unlock_actions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load skill_unlock_actions")
	}

	var resultSlice []*SkillUnlockAction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice skill_unlock_actions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on skill_unlock_actions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for skill_unlock_actions")
	}

	if len(skillUnlockActionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SkillUnlockActions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &skillUnlockActionR{}
			}
			foreign.R.Action = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ActionID {
				local.R.SkillUnlockActions = append(local.R.SkillUnlockActions, foreign)
				if foreign.R == nil {
					foreign.R = &skillUnlockActionR{}
				}
				foreign.R.Action = local
				break
			}
		}
	}

	return nil
}

// SetActionCategoryG of the action to the related item.
// Sets o.R.ActionCategory to related.
// Adds o to related.R.Actions.
// Uses the global database handle.
func (o *Action) SetActionCategoryG(ctx context.Context, insert bool, related *ActionCategory) error {
	return o.SetActionCategory(ctx, boil.GetContextDB(), insert, related)
}

// SetActionCategoryP of the action to the related item.
// Sets o.R.ActionCategory to related.
// Adds o to related.R.Actions.
// Panics on error.
func (o *Action) SetActionCategoryP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ActionCategory) {
	if err := o.SetActionCategory(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetActionCategoryGP of the action to the related item.
// Sets o.R.ActionCategory to related.
// Adds o to related.R.Actions.
// Uses the global database handle and panics on error.
func (o *Action) SetActionCategoryGP(ctx context.Context, insert bool, related *ActionCategory) {
	if err := o.SetActionCategory(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetActionCategory of the action to the related item.
// Sets o.R.ActionCategory to related.
// Adds o to related.R.Actions.
func (o *Action) SetActionCategory(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ActionCategory) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"actions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"action_category_id"}),
		strmangle.WhereClause("\"", "\"", 2, actionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ActionCategoryID, related.ID)
	if o.R == nil {
		o.R = &actionR{
			ActionCategory: related,
		}
	} else {
		o.R.ActionCategory = related
	}

	if related.R == nil {
		related.R = &actionCategoryR{
			Actions: ActionSlice{o},
		}
	} else {
		related.R.Actions = append(related.R.Actions, o)
	}

	return nil
}

// RemoveActionCategoryG relationship.
// Sets o.R.ActionCategory to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Action) RemoveActionCategoryG(ctx context.Context, related *ActionCategory) error {
	return o.RemoveActionCategory(ctx, boil.GetContextDB(), related)
}

// RemoveActionCategoryP relationship.
// Sets o.R.ActionCategory to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Action) RemoveActionCategoryP(ctx context.Context, exec boil.ContextExecutor, related *ActionCategory) {
	if err := o.RemoveActionCategory(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveActionCategoryGP relationship.
// Sets o.R.ActionCategory to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Action) RemoveActionCategoryGP(ctx context.Context, related *ActionCategory) {
	if err := o.RemoveActionCategory(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveActionCategory relationship.
// Sets o.R.ActionCategory to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Action) RemoveActionCategory(ctx context.Context, exec boil.ContextExecutor, related *ActionCategory) error {
	var err error

	queries.SetScanner(&o.ActionCategoryID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("action_category_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ActionCategory = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Actions {
		if queries.Equal(o.ActionCategoryID, ri.ActionCategoryID) {
			continue
		}

		ln := len(related.R.Actions)
		if ln > 1 && i < ln-1 {
			related.R.Actions[i] = related.R.Actions[ln-1]
		}
		related.R.Actions = related.R.Actions[:ln-1]
		break
	}
	return nil
}

// SetRelatedSkillG of the action to the related item.
// Sets o.R.RelatedSkill to related.
// Adds o to related.R.RelatedSkillActions.
// Uses the global database handle.
func (o *Action) SetRelatedSkillG(ctx context.Context, insert bool, related *Skill) error {
	return o.SetRelatedSkill(ctx, boil.GetContextDB(), insert, related)
}

// SetRelatedSkillP of the action to the related item.
// Sets o.R.RelatedSkill to related.
// Adds o to related.R.RelatedSkillActions.
// Panics on error.
func (o *Action) SetRelatedSkillP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Skill) {
	if err := o.SetRelatedSkill(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetRelatedSkillGP of the action to the related item.
// Sets o.R.RelatedSkill to related.
// Adds o to related.R.RelatedSkillActions.
// Uses the global database handle and panics on error.
func (o *Action) SetRelatedSkillGP(ctx context.Context, insert bool, related *Skill) {
	if err := o.SetRelatedSkill(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetRelatedSkill of the action to the related item.
// Sets o.R.RelatedSkill to related.
// Adds o to related.R.RelatedSkillActions.
func (o *Action) SetRelatedSkill(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Skill) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"actions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"related_skill_id"}),
		strmangle.WhereClause("\"", "\"", 2, actionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.RelatedSkillID, related.ID)
	if o.R == nil {
		o.R = &actionR{
			RelatedSkill: related,
		}
	} else {
		o.R.RelatedSkill = related
	}

	if related.R == nil {
		related.R = &skillR{
			RelatedSkillActions: ActionSlice{o},
		}
	} else {
		related.R.RelatedSkillActions = append(related.R.RelatedSkillActions, o)
	}

	return nil
}

// RemoveRelatedSkillG relationship.
// Sets o.R.RelatedSkill to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Action) RemoveRelatedSkillG(ctx context.Context, related *Skill) error {
	return o.RemoveRelatedSkill(ctx, boil.GetContextDB(), related)
}

// RemoveRelatedSkillP relationship.
// Sets o.R.RelatedSkill to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Action) RemoveRelatedSkillP(ctx context.Context, exec boil.ContextExecutor, related *Skill) {
	if err := o.RemoveRelatedSkill(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveRelatedSkillGP relationship.
// Sets o.R.RelatedSkill to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Action) RemoveRelatedSkillGP(ctx context.Context, related *Skill) {
	if err := o.RemoveRelatedSkill(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveRelatedSkill relationship.
// Sets o.R.RelatedSkill to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Action) RemoveRelatedSkill(ctx context.Context, exec boil.ContextExecutor, related *Skill) error {
	var err error

	queries.SetScanner(&o.RelatedSkillID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("related_skill_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.RelatedSkill = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.RelatedSkillActions {
		if queries.Equal(o.RelatedSkillID, ri.RelatedSkillID) {
			continue
		}

		ln := len(related.R.RelatedSkillActions)
		if ln > 1 && i < ln-1 {
			related.R.RelatedSkillActions[i] = related.R.RelatedSkillActions[ln-1]
		}
		related.R.RelatedSkillActions = related.R.RelatedSkillActions[:ln-1]
		break
	}
	return nil
}

// AddActionEffectsG adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.ActionEffects.
// Sets related.R.Action appropriately.
// Uses the global database handle.
func (o *Action) AddActionEffectsG(ctx context.Context, insert bool, related ...*ActionEffect) error {
	return o.AddActionEffects(ctx, boil.GetContextDB(), insert, related...)
}

// AddActionEffectsP adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.ActionEffects.
// Sets related.R.Action appropriately.
// Panics on error.
func (o *Action) AddActionEffectsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ActionEffect) {
	if err := o.AddActionEffects(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddActionEffectsGP adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.ActionEffects.
// Sets related.R.Action appropriately.
// Uses the global database handle and panics on error.
func (o *Action) AddActionEffectsGP(ctx context.Context, insert bool, related ...*ActionEffect) {
	if err := o.AddActionEffects(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddActionEffects adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.ActionEffects.
// Sets related.R.Action appropriately.
func (o *Action) AddActionEffects(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ActionEffect) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ActionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"action_effects\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"action_id"}),
				strmangle.WhereClause("\"", "\"", 2, actionEffectPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ActionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &actionR{
			ActionEffects: related,
		}
	} else {
		o.R.ActionEffects = append(o.R.ActionEffects, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &actionEffectR{
				Action: o,
			}
		} else {
			rel.R.Action = o
		}
	}
	return nil
}

// AddSkillUnlockActionsG adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.SkillUnlockActions.
// Sets related.R.Action appropriately.
// Uses the global database handle.
func (o *Action) AddSkillUnlockActionsG(ctx context.Context, insert bool, related ...*SkillUnlockAction) error {
	return o.AddSkillUnlockActions(ctx, boil.GetContextDB(), insert, related...)
}

// AddSkillUnlockActionsP adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.SkillUnlockActions.
// Sets related.R.Action appropriately.
// Panics on error.
func (o *Action) AddSkillUnlockActionsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SkillUnlockAction) {
	if err := o.AddSkillUnlockActions(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddSkillUnlockActionsGP adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.SkillUnlockActions.
// Sets related.R.Action appropriately.
// Uses the global database handle and panics on error.
func (o *Action) AddSkillUnlockActionsGP(ctx context.Context, insert bool, related ...*SkillUnlockAction) {
	if err := o.AddSkillUnlockActions(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddSkillUnlockActions adds the given related objects to the existing relationships
// of the action, optionally inserting them as new records.
// Appends related to o.R.SkillUnlockActions.
// Sets related.R.Action appropriately.
func (o *Action) AddSkillUnlockActions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SkillUnlockAction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ActionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"skill_unlock_actions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"action_id"}),
				strmangle.WhereClause("\"", "\"", 2, skillUnlockActionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ActionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &actionR{
			SkillUnlockActions: related,
		}
	} else {
		o.R.SkillUnlockActions = append(o.R.SkillUnlockActions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &skillUnlockActionR{
				Action: o,
			}
		} else {
			rel.R.Action = o
		}
	}
	return nil
}

// Actions retrieves all the records using an executor.
func Actions(mods ...qm.QueryMod) actionQuery {
	mods = append(mods, qm.From("\"game_config\".\"actions\""), qmhelper.WhereIsNull("\"game_config\".\"actions\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_config\".\"actions\".*"})
	}

	return actionQuery{q}
}

// FindActionG retrieves a single record by ID.
func FindActionG(ctx context.Context, iD string, selectCols ...string) (*Action, error) {
	return FindAction(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindActionP retrieves a single record by ID with an executor, and panics on error.
func FindActionP(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) *Action {
	retobj, err := FindAction(ctx, exec, iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindActionGP retrieves a single record by ID, and panics on error.
func FindActionGP(ctx context.Context, iD string, selectCols ...string) *Action {
	retobj, err := FindAction(ctx, boil.GetContextDB(), iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindAction retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAction(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Action, error) {
	actionObj := &Action{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_config\".\"actions\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, actionObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: unable to select from actions")
	}

	if err = actionObj.doAfterSelectHooks(ctx, exec); err != nil {
		return actionObj, err
	}

	return actionObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Action) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *Action) InsertP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) {
	if err := o.Insert(ctx, exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *Action) InsertGP(ctx context.Context, columns boil.Columns) {
	if err := o.Insert(ctx, boil.GetContextDB(), columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Action) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("game_config: no actions provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(actionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	actionInsertCacheMut.RLock()
	cache, cached := actionInsertCache[key]
	actionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			actionAllColumns,
			actionColumnsWithDefault,
			actionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(actionType, actionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(actionType, actionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_config\".\"actions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_config\".\"actions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "game_config: unable to insert into actions")
	}

	if !cached {
		actionInsertCacheMut.Lock()
		actionInsertCache[key] = cache
		actionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Action record using the global executor.
// See Update for more documentation.
func (o *Action) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// UpdateP uses an executor to update the Action, and panics on error.
// See Update for more documentation.
func (o *Action) UpdateP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateGP a single Action record using the global executor. Panics on error.
// See Update for more documentation.
func (o *Action) UpdateGP(ctx context.Context, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, boil.GetContextDB(), columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Update uses an executor to update the Action.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Action) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	actionUpdateCacheMut.RLock()
	cache, cached := actionUpdateCache[key]
	actionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			actionAllColumns,
			actionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("game_config: unable to update actions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_config\".\"actions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, actionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(actionType, actionMapping, append(wl, actionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update actions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by update for actions")
	}

	if !cached {
		actionUpdateCacheMut.Lock()
		actionUpdateCache[key] = cache
		actionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q actionQuery) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllG updates all rows with the specified column values.
func (q actionQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (q actionQuery) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values.
func (q actionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all for actions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected for actions")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ActionSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o ActionSlice) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o ActionSlice) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ActionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("game_config: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), actionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_config\".\"actions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, actionPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all in action slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected all in update all action")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Action) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *Action) UpsertGP(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *Action) UpsertP(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, exec, updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Action) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("game_config: no actions provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(actionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	actionUpsertCacheMut.RLock()
	cache, cached := actionUpsertCache[key]
	actionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			actionAllColumns,
			actionColumnsWithDefault,
			actionColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			actionAllColumns,
			actionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("game_config: unable to upsert actions, could not build update column list")
		}

		ret := strmangle.SetComplement(actionAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(actionPrimaryKeyColumns) == 0 {
				return errors.New("game_config: unable to upsert actions, could not build conflict column list")
			}

			conflict = make([]string, len(actionPrimaryKeyColumns))
			copy(conflict, actionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_config\".\"actions\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(actionType, actionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(actionType, actionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "game_config: unable to upsert actions")
	}

	if !cached {
		actionUpsertCacheMut.Lock()
		actionUpsertCache[key] = cache
		actionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Action record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Action) DeleteG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteP deletes a single Action record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Action) DeleteP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteGP deletes a single Action record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Action) DeleteGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Delete deletes a single Action record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Action) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("game_config: no Action provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), actionPrimaryKeyMapping)
		sql = "DELETE FROM \"game_config\".\"actions\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"actions\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(actionType, actionMapping, append(wl, actionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete from actions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by delete for actions")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q actionQuery) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows, and panics on error.
func (q actionQuery) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows, and panics on error.
func (q actionQuery) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all matching rows.
func (q actionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("game_config: no actionQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from actions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for actions")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ActionSlice) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o ActionSlice) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o ActionSlice) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ActionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(actionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), actionPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"game_config\".\"actions\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, actionPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), actionPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"actions\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, actionPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from action slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for actions")
	}

	if len(actionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Action) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: no Action provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *Action) ReloadP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.Reload(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadGP refetches the object from the database and panics on error.
func (o *Action) ReloadGP(ctx context.Context) {
	if err := o.Reload(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Action) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAction(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ActionSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: empty ActionSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *ActionSlice) ReloadAllP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.ReloadAll(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *ActionSlice) ReloadAllGP(ctx context.Context) {
	if err := o.ReloadAll(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ActionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ActionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), actionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_config\".\"actions\".* FROM \"game_config\".\"actions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, actionPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "game_config: unable to reload all in ActionSlice")
	}

	*o = slice

	return nil
}

// ActionExistsG checks if the Action row exists.
func ActionExistsG(ctx context.Context, iD string) (bool, error) {
	return ActionExists(ctx, boil.GetContextDB(), iD)
}

// ActionExistsP checks if the Action row exists. Panics on error.
func ActionExistsP(ctx context.Context, exec boil.ContextExecutor, iD string) bool {
	e, err := ActionExists(ctx, exec, iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ActionExistsGP checks if the Action row exists. Panics on error.
func ActionExistsGP(ctx context.Context, iD string) bool {
	e, err := ActionExists(ctx, boil.GetContextDB(), iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ActionExists checks if the Action row exists.
func ActionExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_config\".\"actions\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "game_config: unable to check if actions exists")
	}

	return exists, nil
}

// Exists checks if the Action row exists.
func (o *Action) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ActionExists(ctx, exec, o.ID)
}
