// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package game_config

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Dungeon is an object representing the database table.
type Dungeon struct {
	ID string `boil:"id" json:"id" toml:"id" yaml:"id"`
	// 地城代码 - 全局唯一标识符
	DungeonCode string `boil:"dungeon_code" json:"dungeon_code" toml:"dungeon_code" yaml:"dungeon_code"`
	// 地城名称 - 显示给玩家的名称
	DungeonName string `boil:"dungeon_name" json:"dungeon_name" toml:"dungeon_name" yaml:"dungeon_name"`
	// 最小等级 - 进入地城的最低等级要求
	MinLevel int16 `boil:"min_level" json:"min_level" toml:"min_level" yaml:"min_level"`
	// 最大等级 - 进入地城的最高等级要求
	MaxLevel int16 `boil:"max_level" json:"max_level" toml:"max_level" yaml:"max_level"`
	// 地城描述 - 地城的背景故事和说明
	Description null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	// 是否限时 - 地城是否只在特定时间段开放
	IsTimeLimited bool `boil:"is_time_limited" json:"is_time_limited" toml:"is_time_limited" yaml:"is_time_limited"`
	// 限时开始时间 - 地城开放的开始时间
	TimeLimitStart null.Time `boil:"time_limit_start" json:"time_limit_start,omitempty" toml:"time_limit_start" yaml:"time_limit_start,omitempty"`
	// 限时结束时间 - 地城开放的结束时间
	TimeLimitEnd null.Time `boil:"time_limit_end" json:"time_limit_end,omitempty" toml:"time_limit_end" yaml:"time_limit_end,omitempty"`
	// 是否需要挑战次数 - 是否限制每日挑战次数
	RequiresAttempts bool `boil:"requires_attempts" json:"requires_attempts" toml:"requires_attempts" yaml:"requires_attempts"`
	// 每日最大挑战次数 - 每天可以挑战的最大次数
	MaxAttemptsPerDay null.Int16 `boil:"max_attempts_per_day" json:"max_attempts_per_day,omitempty" toml:"max_attempts_per_day" yaml:"max_attempts_per_day,omitempty"`
	// 房间序列 - JSONB格式,定义房间的顺序和条件分支
	RoomSequence types.JSON `boil:"room_sequence" json:"room_sequence" toml:"room_sequence" yaml:"room_sequence"`
	// 是否启用 - 地城是否对玩家开放
	IsActive  bool      `boil:"is_active" json:"is_active" toml:"is_active" yaml:"is_active"`
	CreatedAt time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt null.Time `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *dungeonR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dungeonL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DungeonColumns = struct {
	ID                string
	DungeonCode       string
	DungeonName       string
	MinLevel          string
	MaxLevel          string
	Description       string
	IsTimeLimited     string
	TimeLimitStart    string
	TimeLimitEnd      string
	RequiresAttempts  string
	MaxAttemptsPerDay string
	RoomSequence      string
	IsActive          string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
}{
	ID:                "id",
	DungeonCode:       "dungeon_code",
	DungeonName:       "dungeon_name",
	MinLevel:          "min_level",
	MaxLevel:          "max_level",
	Description:       "description",
	IsTimeLimited:     "is_time_limited",
	TimeLimitStart:    "time_limit_start",
	TimeLimitEnd:      "time_limit_end",
	RequiresAttempts:  "requires_attempts",
	MaxAttemptsPerDay: "max_attempts_per_day",
	RoomSequence:      "room_sequence",
	IsActive:          "is_active",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
	DeletedAt:         "deleted_at",
}

var DungeonTableColumns = struct {
	ID                string
	DungeonCode       string
	DungeonName       string
	MinLevel          string
	MaxLevel          string
	Description       string
	IsTimeLimited     string
	TimeLimitStart    string
	TimeLimitEnd      string
	RequiresAttempts  string
	MaxAttemptsPerDay string
	RoomSequence      string
	IsActive          string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
}{
	ID:                "dungeons.id",
	DungeonCode:       "dungeons.dungeon_code",
	DungeonName:       "dungeons.dungeon_name",
	MinLevel:          "dungeons.min_level",
	MaxLevel:          "dungeons.max_level",
	Description:       "dungeons.description",
	IsTimeLimited:     "dungeons.is_time_limited",
	TimeLimitStart:    "dungeons.time_limit_start",
	TimeLimitEnd:      "dungeons.time_limit_end",
	RequiresAttempts:  "dungeons.requires_attempts",
	MaxAttemptsPerDay: "dungeons.max_attempts_per_day",
	RoomSequence:      "dungeons.room_sequence",
	IsActive:          "dungeons.is_active",
	CreatedAt:         "dungeons.created_at",
	UpdatedAt:         "dungeons.updated_at",
	DeletedAt:         "dungeons.deleted_at",
}

// Generated where

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var DungeonWhere = struct {
	ID                whereHelperstring
	DungeonCode       whereHelperstring
	DungeonName       whereHelperstring
	MinLevel          whereHelperint16
	MaxLevel          whereHelperint16
	Description       whereHelpernull_String
	IsTimeLimited     whereHelperbool
	TimeLimitStart    whereHelpernull_Time
	TimeLimitEnd      whereHelpernull_Time
	RequiresAttempts  whereHelperbool
	MaxAttemptsPerDay whereHelpernull_Int16
	RoomSequence      whereHelpertypes_JSON
	IsActive          whereHelperbool
	CreatedAt         whereHelpertime_Time
	UpdatedAt         whereHelpertime_Time
	DeletedAt         whereHelpernull_Time
}{
	ID:                whereHelperstring{field: "\"game_config\".\"dungeons\".\"id\""},
	DungeonCode:       whereHelperstring{field: "\"game_config\".\"dungeons\".\"dungeon_code\""},
	DungeonName:       whereHelperstring{field: "\"game_config\".\"dungeons\".\"dungeon_name\""},
	MinLevel:          whereHelperint16{field: "\"game_config\".\"dungeons\".\"min_level\""},
	MaxLevel:          whereHelperint16{field: "\"game_config\".\"dungeons\".\"max_level\""},
	Description:       whereHelpernull_String{field: "\"game_config\".\"dungeons\".\"description\""},
	IsTimeLimited:     whereHelperbool{field: "\"game_config\".\"dungeons\".\"is_time_limited\""},
	TimeLimitStart:    whereHelpernull_Time{field: "\"game_config\".\"dungeons\".\"time_limit_start\""},
	TimeLimitEnd:      whereHelpernull_Time{field: "\"game_config\".\"dungeons\".\"time_limit_end\""},
	RequiresAttempts:  whereHelperbool{field: "\"game_config\".\"dungeons\".\"requires_attempts\""},
	MaxAttemptsPerDay: whereHelpernull_Int16{field: "\"game_config\".\"dungeons\".\"max_attempts_per_day\""},
	RoomSequence:      whereHelpertypes_JSON{field: "\"game_config\".\"dungeons\".\"room_sequence\""},
	IsActive:          whereHelperbool{field: "\"game_config\".\"dungeons\".\"is_active\""},
	CreatedAt:         whereHelpertime_Time{field: "\"game_config\".\"dungeons\".\"created_at\""},
	UpdatedAt:         whereHelpertime_Time{field: "\"game_config\".\"dungeons\".\"updated_at\""},
	DeletedAt:         whereHelpernull_Time{field: "\"game_config\".\"dungeons\".\"deleted_at\""},
}

// DungeonRels is where relationship names are stored.
var DungeonRels = struct {
}{}

// dungeonR is where relationships are stored.
type dungeonR struct {
}

// NewStruct creates a new relationship struct
func (*dungeonR) NewStruct() *dungeonR {
	return &dungeonR{}
}

// dungeonL is where Load methods for each relationship are stored.
type dungeonL struct{}

var (
	dungeonAllColumns            = []string{"id", "dungeon_code", "dungeon_name", "min_level", "max_level", "description", "is_time_limited", "time_limit_start", "time_limit_end", "requires_attempts", "max_attempts_per_day", "room_sequence", "is_active", "created_at", "updated_at", "deleted_at"}
	dungeonColumnsWithoutDefault = []string{"dungeon_code", "dungeon_name", "min_level", "max_level"}
	dungeonColumnsWithDefault    = []string{"id", "description", "is_time_limited", "time_limit_start", "time_limit_end", "requires_attempts", "max_attempts_per_day", "room_sequence", "is_active", "created_at", "updated_at", "deleted_at"}
	dungeonPrimaryKeyColumns     = []string{"id"}
	dungeonGeneratedColumns      = []string{}
)

type (
	// DungeonSlice is an alias for a slice of pointers to Dungeon.
	// This should almost always be used instead of []Dungeon.
	DungeonSlice []*Dungeon
	// DungeonHook is the signature for custom Dungeon hook methods
	DungeonHook func(context.Context, boil.ContextExecutor, *Dungeon) error

	dungeonQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dungeonType                 = reflect.TypeOf(&Dungeon{})
	dungeonMapping              = queries.MakeStructMapping(dungeonType)
	dungeonPrimaryKeyMapping, _ = queries.BindMapping(dungeonType, dungeonMapping, dungeonPrimaryKeyColumns)
	dungeonInsertCacheMut       sync.RWMutex
	dungeonInsertCache          = make(map[string]insertCache)
	dungeonUpdateCacheMut       sync.RWMutex
	dungeonUpdateCache          = make(map[string]updateCache)
	dungeonUpsertCacheMut       sync.RWMutex
	dungeonUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dungeonAfterSelectMu sync.Mutex
var dungeonAfterSelectHooks []DungeonHook

var dungeonBeforeInsertMu sync.Mutex
var dungeonBeforeInsertHooks []DungeonHook
var dungeonAfterInsertMu sync.Mutex
var dungeonAfterInsertHooks []DungeonHook

var dungeonBeforeUpdateMu sync.Mutex
var dungeonBeforeUpdateHooks []DungeonHook
var dungeonAfterUpdateMu sync.Mutex
var dungeonAfterUpdateHooks []DungeonHook

var dungeonBeforeDeleteMu sync.Mutex
var dungeonBeforeDeleteHooks []DungeonHook
var dungeonAfterDeleteMu sync.Mutex
var dungeonAfterDeleteHooks []DungeonHook

var dungeonBeforeUpsertMu sync.Mutex
var dungeonBeforeUpsertHooks []DungeonHook
var dungeonAfterUpsertMu sync.Mutex
var dungeonAfterUpsertHooks []DungeonHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Dungeon) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Dungeon) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Dungeon) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Dungeon) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Dungeon) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Dungeon) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Dungeon) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Dungeon) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Dungeon) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dungeonAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDungeonHook registers your hook function for all future operations.
func AddDungeonHook(hookPoint boil.HookPoint, dungeonHook DungeonHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		dungeonAfterSelectMu.Lock()
		dungeonAfterSelectHooks = append(dungeonAfterSelectHooks, dungeonHook)
		dungeonAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		dungeonBeforeInsertMu.Lock()
		dungeonBeforeInsertHooks = append(dungeonBeforeInsertHooks, dungeonHook)
		dungeonBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		dungeonAfterInsertMu.Lock()
		dungeonAfterInsertHooks = append(dungeonAfterInsertHooks, dungeonHook)
		dungeonAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		dungeonBeforeUpdateMu.Lock()
		dungeonBeforeUpdateHooks = append(dungeonBeforeUpdateHooks, dungeonHook)
		dungeonBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		dungeonAfterUpdateMu.Lock()
		dungeonAfterUpdateHooks = append(dungeonAfterUpdateHooks, dungeonHook)
		dungeonAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		dungeonBeforeDeleteMu.Lock()
		dungeonBeforeDeleteHooks = append(dungeonBeforeDeleteHooks, dungeonHook)
		dungeonBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		dungeonAfterDeleteMu.Lock()
		dungeonAfterDeleteHooks = append(dungeonAfterDeleteHooks, dungeonHook)
		dungeonAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		dungeonBeforeUpsertMu.Lock()
		dungeonBeforeUpsertHooks = append(dungeonBeforeUpsertHooks, dungeonHook)
		dungeonBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		dungeonAfterUpsertMu.Lock()
		dungeonAfterUpsertHooks = append(dungeonAfterUpsertHooks, dungeonHook)
		dungeonAfterUpsertMu.Unlock()
	}
}

// OneG returns a single dungeon record from the query using the global executor.
func (q dungeonQuery) OneG(ctx context.Context) (*Dungeon, error) {
	return q.One(ctx, boil.GetContextDB())
}

// OneGP returns a single dungeon record from the query using the global executor, and panics on error.
func (q dungeonQuery) OneGP(ctx context.Context) *Dungeon {
	o, err := q.One(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single dungeon record from the query, and panics on error.
func (q dungeonQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *Dungeon {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single dungeon record from the query.
func (q dungeonQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Dungeon, error) {
	o := &Dungeon{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: failed to execute a one query for dungeons")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Dungeon records from the query using the global executor.
func (q dungeonQuery) AllG(ctx context.Context) (DungeonSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// AllGP returns all Dungeon records from the query using the global executor, and panics on error.
func (q dungeonQuery) AllGP(ctx context.Context) DungeonSlice {
	o, err := q.All(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all Dungeon records from the query, and panics on error.
func (q dungeonQuery) AllP(ctx context.Context, exec boil.ContextExecutor) DungeonSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all Dungeon records from the query.
func (q dungeonQuery) All(ctx context.Context, exec boil.ContextExecutor) (DungeonSlice, error) {
	var o []*Dungeon

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "game_config: failed to assign all query results to Dungeon slice")
	}

	if len(dungeonAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Dungeon records in the query using the global executor
func (q dungeonQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// CountGP returns the count of all Dungeon records in the query using the global executor, and panics on error.
func (q dungeonQuery) CountGP(ctx context.Context) int64 {
	c, err := q.Count(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all Dungeon records in the query, and panics on error.
func (q dungeonQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all Dungeon records in the query.
func (q dungeonQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to count dungeons rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q dungeonQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q dungeonQuery) ExistsGP(ctx context.Context) bool {
	e, err := q.Exists(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q dungeonQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q dungeonQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "game_config: failed to check if dungeons exists")
	}

	return count > 0, nil
}

// Dungeons retrieves all the records using an executor.
func Dungeons(mods ...qm.QueryMod) dungeonQuery {
	mods = append(mods, qm.From("\"game_config\".\"dungeons\""), qmhelper.WhereIsNull("\"game_config\".\"dungeons\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_config\".\"dungeons\".*"})
	}

	return dungeonQuery{q}
}

// FindDungeonG retrieves a single record by ID.
func FindDungeonG(ctx context.Context, iD string, selectCols ...string) (*Dungeon, error) {
	return FindDungeon(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindDungeonP retrieves a single record by ID with an executor, and panics on error.
func FindDungeonP(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) *Dungeon {
	retobj, err := FindDungeon(ctx, exec, iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindDungeonGP retrieves a single record by ID, and panics on error.
func FindDungeonGP(ctx context.Context, iD string, selectCols ...string) *Dungeon {
	retobj, err := FindDungeon(ctx, boil.GetContextDB(), iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindDungeon retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDungeon(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Dungeon, error) {
	dungeonObj := &Dungeon{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_config\".\"dungeons\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dungeonObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: unable to select from dungeons")
	}

	if err = dungeonObj.doAfterSelectHooks(ctx, exec); err != nil {
		return dungeonObj, err
	}

	return dungeonObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Dungeon) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *Dungeon) InsertP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) {
	if err := o.Insert(ctx, exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *Dungeon) InsertGP(ctx context.Context, columns boil.Columns) {
	if err := o.Insert(ctx, boil.GetContextDB(), columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Dungeon) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("game_config: no dungeons provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dungeonColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dungeonInsertCacheMut.RLock()
	cache, cached := dungeonInsertCache[key]
	dungeonInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dungeonAllColumns,
			dungeonColumnsWithDefault,
			dungeonColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dungeonType, dungeonMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dungeonType, dungeonMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_config\".\"dungeons\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_config\".\"dungeons\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "game_config: unable to insert into dungeons")
	}

	if !cached {
		dungeonInsertCacheMut.Lock()
		dungeonInsertCache[key] = cache
		dungeonInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Dungeon record using the global executor.
// See Update for more documentation.
func (o *Dungeon) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// UpdateP uses an executor to update the Dungeon, and panics on error.
// See Update for more documentation.
func (o *Dungeon) UpdateP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateGP a single Dungeon record using the global executor. Panics on error.
// See Update for more documentation.
func (o *Dungeon) UpdateGP(ctx context.Context, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, boil.GetContextDB(), columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Update uses an executor to update the Dungeon.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Dungeon) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dungeonUpdateCacheMut.RLock()
	cache, cached := dungeonUpdateCache[key]
	dungeonUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dungeonAllColumns,
			dungeonPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("game_config: unable to update dungeons, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_config\".\"dungeons\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, dungeonPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dungeonType, dungeonMapping, append(wl, dungeonPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update dungeons row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by update for dungeons")
	}

	if !cached {
		dungeonUpdateCacheMut.Lock()
		dungeonUpdateCache[key] = cache
		dungeonUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q dungeonQuery) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllG updates all rows with the specified column values.
func (q dungeonQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (q dungeonQuery) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values.
func (q dungeonQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all for dungeons")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected for dungeons")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o DungeonSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o DungeonSlice) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o DungeonSlice) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DungeonSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("game_config: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dungeonPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_config\".\"dungeons\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, dungeonPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all in dungeon slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected all in update all dungeon")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Dungeon) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *Dungeon) UpsertGP(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *Dungeon) UpsertP(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, exec, updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Dungeon) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("game_config: no dungeons provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dungeonColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dungeonUpsertCacheMut.RLock()
	cache, cached := dungeonUpsertCache[key]
	dungeonUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			dungeonAllColumns,
			dungeonColumnsWithDefault,
			dungeonColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dungeonAllColumns,
			dungeonPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("game_config: unable to upsert dungeons, could not build update column list")
		}

		ret := strmangle.SetComplement(dungeonAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(dungeonPrimaryKeyColumns) == 0 {
				return errors.New("game_config: unable to upsert dungeons, could not build conflict column list")
			}

			conflict = make([]string, len(dungeonPrimaryKeyColumns))
			copy(conflict, dungeonPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_config\".\"dungeons\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(dungeonType, dungeonMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dungeonType, dungeonMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "game_config: unable to upsert dungeons")
	}

	if !cached {
		dungeonUpsertCacheMut.Lock()
		dungeonUpsertCache[key] = cache
		dungeonUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Dungeon record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Dungeon) DeleteG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteP deletes a single Dungeon record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Dungeon) DeleteP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteGP deletes a single Dungeon record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Dungeon) DeleteGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Delete deletes a single Dungeon record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Dungeon) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("game_config: no Dungeon provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dungeonPrimaryKeyMapping)
		sql = "DELETE FROM \"game_config\".\"dungeons\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"dungeons\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(dungeonType, dungeonMapping, append(wl, dungeonPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete from dungeons")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by delete for dungeons")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q dungeonQuery) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows, and panics on error.
func (q dungeonQuery) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows, and panics on error.
func (q dungeonQuery) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all matching rows.
func (q dungeonQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("game_config: no dungeonQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from dungeons")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for dungeons")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o DungeonSlice) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o DungeonSlice) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o DungeonSlice) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DungeonSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(dungeonBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dungeonPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"game_config\".\"dungeons\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, dungeonPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dungeonPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"dungeons\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, dungeonPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from dungeon slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for dungeons")
	}

	if len(dungeonAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Dungeon) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: no Dungeon provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *Dungeon) ReloadP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.Reload(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadGP refetches the object from the database and panics on error.
func (o *Dungeon) ReloadGP(ctx context.Context) {
	if err := o.Reload(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Dungeon) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDungeon(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DungeonSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: empty DungeonSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *DungeonSlice) ReloadAllP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.ReloadAll(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *DungeonSlice) ReloadAllGP(ctx context.Context) {
	if err := o.ReloadAll(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DungeonSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DungeonSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dungeonPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_config\".\"dungeons\".* FROM \"game_config\".\"dungeons\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, dungeonPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "game_config: unable to reload all in DungeonSlice")
	}

	*o = slice

	return nil
}

// DungeonExistsG checks if the Dungeon row exists.
func DungeonExistsG(ctx context.Context, iD string) (bool, error) {
	return DungeonExists(ctx, boil.GetContextDB(), iD)
}

// DungeonExistsP checks if the Dungeon row exists. Panics on error.
func DungeonExistsP(ctx context.Context, exec boil.ContextExecutor, iD string) bool {
	e, err := DungeonExists(ctx, exec, iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// DungeonExistsGP checks if the Dungeon row exists. Panics on error.
func DungeonExistsGP(ctx context.Context, iD string) bool {
	e, err := DungeonExists(ctx, boil.GetContextDB(), iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// DungeonExists checks if the Dungeon row exists.
func DungeonExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_config\".\"dungeons\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "game_config: unable to check if dungeons exists")
	}

	return exists, nil
}

// Exists checks if the Dungeon row exists.
func (o *Dungeon) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DungeonExists(ctx, exec, o.ID)
}
