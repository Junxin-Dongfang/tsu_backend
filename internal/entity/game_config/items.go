// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package game_config

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Item is an object representing the database table.
type Item struct {
	ID       string `boil:"id" json:"id" toml:"id" yaml:"id"`
	ItemCode string `boil:"item_code" json:"item_code" toml:"item_code" yaml:"item_code"`
	ItemName string `boil:"item_name" json:"item_name" toml:"item_name" yaml:"item_name"`
	// 物品类型 - equipment(装备)/consumable(消耗品)/gem(宝石)/repair_material(修复材料)/enhancement_material(强化材料)/material(材料)/other(其他)
	ItemType       string      `boil:"item_type" json:"item_type" toml:"item_type" yaml:"item_type"`
	ItemQuality    string      `boil:"item_quality" json:"item_quality" toml:"item_quality" yaml:"item_quality"`
	ItemLevel      int16       `boil:"item_level" json:"item_level" toml:"item_level" yaml:"item_level"`
	Description    null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	IconURL        null.String `boil:"icon_url" json:"icon_url,omitempty" toml:"icon_url" yaml:"icon_url,omitempty"`
	EquipSlot      null.String `boil:"equip_slot" json:"equip_slot,omitempty" toml:"equip_slot" yaml:"equip_slot,omitempty"`
	RequiredLevel  null.Int16  `boil:"required_level" json:"required_level,omitempty" toml:"required_level" yaml:"required_level,omitempty"`
	MaterialType   null.String `boil:"material_type" json:"material_type,omitempty" toml:"material_type" yaml:"material_type,omitempty"`
	MaxDurability  null.Int    `boil:"max_durability" json:"max_durability,omitempty" toml:"max_durability" yaml:"max_durability,omitempty"`
	UniquenessType null.String `boil:"uniqueness_type" json:"uniqueness_type,omitempty" toml:"uniqueness_type" yaml:"uniqueness_type,omitempty"`
	// 局外效果 - 直接影响英雄属性的效果,格式: [{"Data_type":"Status","Data_ID":"MAX_HP","Bouns_type":"bonus","Bouns_Number":"5"}]
	OutOfCombatEffects null.JSON `boil:"out_of_combat_effects" json:"out_of_combat_effects,omitempty" toml:"out_of_combat_effects" yaml:"out_of_combat_effects,omitempty"`
	// 局内效果 - 战斗时触发的效果,格式: [{"Effect":"APPLY_BUFF","params":{...}}]
	InCombatEffects null.JSON         `boil:"in_combat_effects" json:"in_combat_effects,omitempty" toml:"in_combat_effects" yaml:"in_combat_effects,omitempty"`
	UseEffects      null.JSON         `boil:"use_effects" json:"use_effects,omitempty" toml:"use_effects" yaml:"use_effects,omitempty"`
	ProvidedSkills  types.StringArray `boil:"provided_skills" json:"provided_skills,omitempty" toml:"provided_skills" yaml:"provided_skills,omitempty"`
	// 孔位类型 - A-I,对应socket_type_configs表的socket_type_code
	SocketType              null.String       `boil:"socket_type" json:"socket_type,omitempty" toml:"socket_type" yaml:"socket_type,omitempty"`
	SocketCount             null.Int16        `boil:"socket_count" json:"socket_count,omitempty" toml:"socket_count" yaml:"socket_count,omitempty"`
	EnhancementMaterialID   null.String       `boil:"enhancement_material_id" json:"enhancement_material_id,omitempty" toml:"enhancement_material_id" yaml:"enhancement_material_id,omitempty"`
	EnhancementCostGold     null.Int          `boil:"enhancement_cost_gold" json:"enhancement_cost_gold,omitempty" toml:"enhancement_cost_gold" yaml:"enhancement_cost_gold,omitempty"`
	GemColor                null.String       `boil:"gem_color" json:"gem_color,omitempty" toml:"gem_color" yaml:"gem_color,omitempty"`
	GemSize                 null.String       `boil:"gem_size" json:"gem_size,omitempty" toml:"gem_size" yaml:"gem_size,omitempty"`
	RepairDurabilityAmount  null.Int          `boil:"repair_durability_amount" json:"repair_durability_amount,omitempty" toml:"repair_durability_amount" yaml:"repair_durability_amount,omitempty"`
	RepairApplicableQuality types.StringArray `boil:"repair_applicable_quality" json:"repair_applicable_quality,omitempty" toml:"repair_applicable_quality" yaml:"repair_applicable_quality,omitempty"`
	RepairMaterialType      null.String       `boil:"repair_material_type" json:"repair_material_type,omitempty" toml:"repair_material_type" yaml:"repair_material_type,omitempty"`
	MaxStackSize            null.Int          `boil:"max_stack_size" json:"max_stack_size,omitempty" toml:"max_stack_size" yaml:"max_stack_size,omitempty"`
	BaseValue               null.Int          `boil:"base_value" json:"base_value,omitempty" toml:"base_value" yaml:"base_value,omitempty"`
	IsTradable              null.Bool         `boil:"is_tradable" json:"is_tradable,omitempty" toml:"is_tradable" yaml:"is_tradable,omitempty"`
	IsDroppable             null.Bool         `boil:"is_droppable" json:"is_droppable,omitempty" toml:"is_droppable" yaml:"is_droppable,omitempty"`
	IsActive                bool              `boil:"is_active" json:"is_active" toml:"is_active" yaml:"is_active"`
	CreatedAt               time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt               time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt               null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	SetID                   null.String       `boil:"set_id" json:"set_id,omitempty" toml:"set_id" yaml:"set_id,omitempty"`

	R *itemR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L itemL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ItemColumns = struct {
	ID                      string
	ItemCode                string
	ItemName                string
	ItemType                string
	ItemQuality             string
	ItemLevel               string
	Description             string
	IconURL                 string
	EquipSlot               string
	RequiredLevel           string
	MaterialType            string
	MaxDurability           string
	UniquenessType          string
	OutOfCombatEffects      string
	InCombatEffects         string
	UseEffects              string
	ProvidedSkills          string
	SocketType              string
	SocketCount             string
	EnhancementMaterialID   string
	EnhancementCostGold     string
	GemColor                string
	GemSize                 string
	RepairDurabilityAmount  string
	RepairApplicableQuality string
	RepairMaterialType      string
	MaxStackSize            string
	BaseValue               string
	IsTradable              string
	IsDroppable             string
	IsActive                string
	CreatedAt               string
	UpdatedAt               string
	DeletedAt               string
	SetID                   string
}{
	ID:                      "id",
	ItemCode:                "item_code",
	ItemName:                "item_name",
	ItemType:                "item_type",
	ItemQuality:             "item_quality",
	ItemLevel:               "item_level",
	Description:             "description",
	IconURL:                 "icon_url",
	EquipSlot:               "equip_slot",
	RequiredLevel:           "required_level",
	MaterialType:            "material_type",
	MaxDurability:           "max_durability",
	UniquenessType:          "uniqueness_type",
	OutOfCombatEffects:      "out_of_combat_effects",
	InCombatEffects:         "in_combat_effects",
	UseEffects:              "use_effects",
	ProvidedSkills:          "provided_skills",
	SocketType:              "socket_type",
	SocketCount:             "socket_count",
	EnhancementMaterialID:   "enhancement_material_id",
	EnhancementCostGold:     "enhancement_cost_gold",
	GemColor:                "gem_color",
	GemSize:                 "gem_size",
	RepairDurabilityAmount:  "repair_durability_amount",
	RepairApplicableQuality: "repair_applicable_quality",
	RepairMaterialType:      "repair_material_type",
	MaxStackSize:            "max_stack_size",
	BaseValue:               "base_value",
	IsTradable:              "is_tradable",
	IsDroppable:             "is_droppable",
	IsActive:                "is_active",
	CreatedAt:               "created_at",
	UpdatedAt:               "updated_at",
	DeletedAt:               "deleted_at",
	SetID:                   "set_id",
}

var ItemTableColumns = struct {
	ID                      string
	ItemCode                string
	ItemName                string
	ItemType                string
	ItemQuality             string
	ItemLevel               string
	Description             string
	IconURL                 string
	EquipSlot               string
	RequiredLevel           string
	MaterialType            string
	MaxDurability           string
	UniquenessType          string
	OutOfCombatEffects      string
	InCombatEffects         string
	UseEffects              string
	ProvidedSkills          string
	SocketType              string
	SocketCount             string
	EnhancementMaterialID   string
	EnhancementCostGold     string
	GemColor                string
	GemSize                 string
	RepairDurabilityAmount  string
	RepairApplicableQuality string
	RepairMaterialType      string
	MaxStackSize            string
	BaseValue               string
	IsTradable              string
	IsDroppable             string
	IsActive                string
	CreatedAt               string
	UpdatedAt               string
	DeletedAt               string
	SetID                   string
}{
	ID:                      "items.id",
	ItemCode:                "items.item_code",
	ItemName:                "items.item_name",
	ItemType:                "items.item_type",
	ItemQuality:             "items.item_quality",
	ItemLevel:               "items.item_level",
	Description:             "items.description",
	IconURL:                 "items.icon_url",
	EquipSlot:               "items.equip_slot",
	RequiredLevel:           "items.required_level",
	MaterialType:            "items.material_type",
	MaxDurability:           "items.max_durability",
	UniquenessType:          "items.uniqueness_type",
	OutOfCombatEffects:      "items.out_of_combat_effects",
	InCombatEffects:         "items.in_combat_effects",
	UseEffects:              "items.use_effects",
	ProvidedSkills:          "items.provided_skills",
	SocketType:              "items.socket_type",
	SocketCount:             "items.socket_count",
	EnhancementMaterialID:   "items.enhancement_material_id",
	EnhancementCostGold:     "items.enhancement_cost_gold",
	GemColor:                "items.gem_color",
	GemSize:                 "items.gem_size",
	RepairDurabilityAmount:  "items.repair_durability_amount",
	RepairApplicableQuality: "items.repair_applicable_quality",
	RepairMaterialType:      "items.repair_material_type",
	MaxStackSize:            "items.max_stack_size",
	BaseValue:               "items.base_value",
	IsTradable:              "items.is_tradable",
	IsDroppable:             "items.is_droppable",
	IsActive:                "items.is_active",
	CreatedAt:               "items.created_at",
	UpdatedAt:               "items.updated_at",
	DeletedAt:               "items.deleted_at",
	SetID:                   "items.set_id",
}

// Generated where

var ItemWhere = struct {
	ID                      whereHelperstring
	ItemCode                whereHelperstring
	ItemName                whereHelperstring
	ItemType                whereHelperstring
	ItemQuality             whereHelperstring
	ItemLevel               whereHelperint16
	Description             whereHelpernull_String
	IconURL                 whereHelpernull_String
	EquipSlot               whereHelpernull_String
	RequiredLevel           whereHelpernull_Int16
	MaterialType            whereHelpernull_String
	MaxDurability           whereHelpernull_Int
	UniquenessType          whereHelpernull_String
	OutOfCombatEffects      whereHelpernull_JSON
	InCombatEffects         whereHelpernull_JSON
	UseEffects              whereHelpernull_JSON
	ProvidedSkills          whereHelpertypes_StringArray
	SocketType              whereHelpernull_String
	SocketCount             whereHelpernull_Int16
	EnhancementMaterialID   whereHelpernull_String
	EnhancementCostGold     whereHelpernull_Int
	GemColor                whereHelpernull_String
	GemSize                 whereHelpernull_String
	RepairDurabilityAmount  whereHelpernull_Int
	RepairApplicableQuality whereHelpertypes_StringArray
	RepairMaterialType      whereHelpernull_String
	MaxStackSize            whereHelpernull_Int
	BaseValue               whereHelpernull_Int
	IsTradable              whereHelpernull_Bool
	IsDroppable             whereHelpernull_Bool
	IsActive                whereHelperbool
	CreatedAt               whereHelpertime_Time
	UpdatedAt               whereHelpertime_Time
	DeletedAt               whereHelpernull_Time
	SetID                   whereHelpernull_String
}{
	ID:                      whereHelperstring{field: "\"game_config\".\"items\".\"id\""},
	ItemCode:                whereHelperstring{field: "\"game_config\".\"items\".\"item_code\""},
	ItemName:                whereHelperstring{field: "\"game_config\".\"items\".\"item_name\""},
	ItemType:                whereHelperstring{field: "\"game_config\".\"items\".\"item_type\""},
	ItemQuality:             whereHelperstring{field: "\"game_config\".\"items\".\"item_quality\""},
	ItemLevel:               whereHelperint16{field: "\"game_config\".\"items\".\"item_level\""},
	Description:             whereHelpernull_String{field: "\"game_config\".\"items\".\"description\""},
	IconURL:                 whereHelpernull_String{field: "\"game_config\".\"items\".\"icon_url\""},
	EquipSlot:               whereHelpernull_String{field: "\"game_config\".\"items\".\"equip_slot\""},
	RequiredLevel:           whereHelpernull_Int16{field: "\"game_config\".\"items\".\"required_level\""},
	MaterialType:            whereHelpernull_String{field: "\"game_config\".\"items\".\"material_type\""},
	MaxDurability:           whereHelpernull_Int{field: "\"game_config\".\"items\".\"max_durability\""},
	UniquenessType:          whereHelpernull_String{field: "\"game_config\".\"items\".\"uniqueness_type\""},
	OutOfCombatEffects:      whereHelpernull_JSON{field: "\"game_config\".\"items\".\"out_of_combat_effects\""},
	InCombatEffects:         whereHelpernull_JSON{field: "\"game_config\".\"items\".\"in_combat_effects\""},
	UseEffects:              whereHelpernull_JSON{field: "\"game_config\".\"items\".\"use_effects\""},
	ProvidedSkills:          whereHelpertypes_StringArray{field: "\"game_config\".\"items\".\"provided_skills\""},
	SocketType:              whereHelpernull_String{field: "\"game_config\".\"items\".\"socket_type\""},
	SocketCount:             whereHelpernull_Int16{field: "\"game_config\".\"items\".\"socket_count\""},
	EnhancementMaterialID:   whereHelpernull_String{field: "\"game_config\".\"items\".\"enhancement_material_id\""},
	EnhancementCostGold:     whereHelpernull_Int{field: "\"game_config\".\"items\".\"enhancement_cost_gold\""},
	GemColor:                whereHelpernull_String{field: "\"game_config\".\"items\".\"gem_color\""},
	GemSize:                 whereHelpernull_String{field: "\"game_config\".\"items\".\"gem_size\""},
	RepairDurabilityAmount:  whereHelpernull_Int{field: "\"game_config\".\"items\".\"repair_durability_amount\""},
	RepairApplicableQuality: whereHelpertypes_StringArray{field: "\"game_config\".\"items\".\"repair_applicable_quality\""},
	RepairMaterialType:      whereHelpernull_String{field: "\"game_config\".\"items\".\"repair_material_type\""},
	MaxStackSize:            whereHelpernull_Int{field: "\"game_config\".\"items\".\"max_stack_size\""},
	BaseValue:               whereHelpernull_Int{field: "\"game_config\".\"items\".\"base_value\""},
	IsTradable:              whereHelpernull_Bool{field: "\"game_config\".\"items\".\"is_tradable\""},
	IsDroppable:             whereHelpernull_Bool{field: "\"game_config\".\"items\".\"is_droppable\""},
	IsActive:                whereHelperbool{field: "\"game_config\".\"items\".\"is_active\""},
	CreatedAt:               whereHelpertime_Time{field: "\"game_config\".\"items\".\"created_at\""},
	UpdatedAt:               whereHelpertime_Time{field: "\"game_config\".\"items\".\"updated_at\""},
	DeletedAt:               whereHelpernull_Time{field: "\"game_config\".\"items\".\"deleted_at\""},
	SetID:                   whereHelpernull_String{field: "\"game_config\".\"items\".\"set_id\""},
}

// ItemRels is where relationship names are stored.
var ItemRels = struct {
	EnhancementMaterial      string
	Set                      string
	DropPoolItems            string
	ItemClassRelations       string
	EnhancementMaterialItems string
	WorldDropConfigs         string
}{
	EnhancementMaterial:      "EnhancementMaterial",
	Set:                      "Set",
	DropPoolItems:            "DropPoolItems",
	ItemClassRelations:       "ItemClassRelations",
	EnhancementMaterialItems: "EnhancementMaterialItems",
	WorldDropConfigs:         "WorldDropConfigs",
}

// itemR is where relationships are stored.
type itemR struct {
	EnhancementMaterial      *Item                  `boil:"EnhancementMaterial" json:"EnhancementMaterial" toml:"EnhancementMaterial" yaml:"EnhancementMaterial"`
	Set                      *EquipmentSetConfig    `boil:"Set" json:"Set" toml:"Set" yaml:"Set"`
	DropPoolItems            DropPoolItemSlice      `boil:"DropPoolItems" json:"DropPoolItems" toml:"DropPoolItems" yaml:"DropPoolItems"`
	ItemClassRelations       ItemClassRelationSlice `boil:"ItemClassRelations" json:"ItemClassRelations" toml:"ItemClassRelations" yaml:"ItemClassRelations"`
	EnhancementMaterialItems ItemSlice              `boil:"EnhancementMaterialItems" json:"EnhancementMaterialItems" toml:"EnhancementMaterialItems" yaml:"EnhancementMaterialItems"`
	WorldDropConfigs         WorldDropConfigSlice   `boil:"WorldDropConfigs" json:"WorldDropConfigs" toml:"WorldDropConfigs" yaml:"WorldDropConfigs"`
}

// NewStruct creates a new relationship struct
func (*itemR) NewStruct() *itemR {
	return &itemR{}
}

func (o *Item) GetEnhancementMaterial() *Item {
	if o == nil {
		return nil
	}

	return o.R.GetEnhancementMaterial()
}

func (r *itemR) GetEnhancementMaterial() *Item {
	if r == nil {
		return nil
	}

	return r.EnhancementMaterial
}

func (o *Item) GetSet() *EquipmentSetConfig {
	if o == nil {
		return nil
	}

	return o.R.GetSet()
}

func (r *itemR) GetSet() *EquipmentSetConfig {
	if r == nil {
		return nil
	}

	return r.Set
}

func (o *Item) GetDropPoolItems() DropPoolItemSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDropPoolItems()
}

func (r *itemR) GetDropPoolItems() DropPoolItemSlice {
	if r == nil {
		return nil
	}

	return r.DropPoolItems
}

func (o *Item) GetItemClassRelations() ItemClassRelationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetItemClassRelations()
}

func (r *itemR) GetItemClassRelations() ItemClassRelationSlice {
	if r == nil {
		return nil
	}

	return r.ItemClassRelations
}

func (o *Item) GetEnhancementMaterialItems() ItemSlice {
	if o == nil {
		return nil
	}

	return o.R.GetEnhancementMaterialItems()
}

func (r *itemR) GetEnhancementMaterialItems() ItemSlice {
	if r == nil {
		return nil
	}

	return r.EnhancementMaterialItems
}

func (o *Item) GetWorldDropConfigs() WorldDropConfigSlice {
	if o == nil {
		return nil
	}

	return o.R.GetWorldDropConfigs()
}

func (r *itemR) GetWorldDropConfigs() WorldDropConfigSlice {
	if r == nil {
		return nil
	}

	return r.WorldDropConfigs
}

// itemL is where Load methods for each relationship are stored.
type itemL struct{}

var (
	itemAllColumns            = []string{"id", "item_code", "item_name", "item_type", "item_quality", "item_level", "description", "icon_url", "equip_slot", "required_level", "material_type", "max_durability", "uniqueness_type", "out_of_combat_effects", "in_combat_effects", "use_effects", "provided_skills", "socket_type", "socket_count", "enhancement_material_id", "enhancement_cost_gold", "gem_color", "gem_size", "repair_durability_amount", "repair_applicable_quality", "repair_material_type", "max_stack_size", "base_value", "is_tradable", "is_droppable", "is_active", "created_at", "updated_at", "deleted_at", "set_id"}
	itemColumnsWithoutDefault = []string{"item_code", "item_name", "item_type", "item_quality"}
	itemColumnsWithDefault    = []string{"id", "item_level", "description", "icon_url", "equip_slot", "required_level", "material_type", "max_durability", "uniqueness_type", "out_of_combat_effects", "in_combat_effects", "use_effects", "provided_skills", "socket_type", "socket_count", "enhancement_material_id", "enhancement_cost_gold", "gem_color", "gem_size", "repair_durability_amount", "repair_applicable_quality", "repair_material_type", "max_stack_size", "base_value", "is_tradable", "is_droppable", "is_active", "created_at", "updated_at", "deleted_at", "set_id"}
	itemPrimaryKeyColumns     = []string{"id"}
	itemGeneratedColumns      = []string{}
)

type (
	// ItemSlice is an alias for a slice of pointers to Item.
	// This should almost always be used instead of []Item.
	ItemSlice []*Item
	// ItemHook is the signature for custom Item hook methods
	ItemHook func(context.Context, boil.ContextExecutor, *Item) error

	itemQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	itemType                 = reflect.TypeOf(&Item{})
	itemMapping              = queries.MakeStructMapping(itemType)
	itemPrimaryKeyMapping, _ = queries.BindMapping(itemType, itemMapping, itemPrimaryKeyColumns)
	itemInsertCacheMut       sync.RWMutex
	itemInsertCache          = make(map[string]insertCache)
	itemUpdateCacheMut       sync.RWMutex
	itemUpdateCache          = make(map[string]updateCache)
	itemUpsertCacheMut       sync.RWMutex
	itemUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var itemAfterSelectMu sync.Mutex
var itemAfterSelectHooks []ItemHook

var itemBeforeInsertMu sync.Mutex
var itemBeforeInsertHooks []ItemHook
var itemAfterInsertMu sync.Mutex
var itemAfterInsertHooks []ItemHook

var itemBeforeUpdateMu sync.Mutex
var itemBeforeUpdateHooks []ItemHook
var itemAfterUpdateMu sync.Mutex
var itemAfterUpdateHooks []ItemHook

var itemBeforeDeleteMu sync.Mutex
var itemBeforeDeleteHooks []ItemHook
var itemAfterDeleteMu sync.Mutex
var itemAfterDeleteHooks []ItemHook

var itemBeforeUpsertMu sync.Mutex
var itemBeforeUpsertHooks []ItemHook
var itemAfterUpsertMu sync.Mutex
var itemAfterUpsertHooks []ItemHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Item) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Item) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Item) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Item) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Item) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Item) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Item) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Item) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Item) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range itemAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddItemHook registers your hook function for all future operations.
func AddItemHook(hookPoint boil.HookPoint, itemHook ItemHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		itemAfterSelectMu.Lock()
		itemAfterSelectHooks = append(itemAfterSelectHooks, itemHook)
		itemAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		itemBeforeInsertMu.Lock()
		itemBeforeInsertHooks = append(itemBeforeInsertHooks, itemHook)
		itemBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		itemAfterInsertMu.Lock()
		itemAfterInsertHooks = append(itemAfterInsertHooks, itemHook)
		itemAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		itemBeforeUpdateMu.Lock()
		itemBeforeUpdateHooks = append(itemBeforeUpdateHooks, itemHook)
		itemBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		itemAfterUpdateMu.Lock()
		itemAfterUpdateHooks = append(itemAfterUpdateHooks, itemHook)
		itemAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		itemBeforeDeleteMu.Lock()
		itemBeforeDeleteHooks = append(itemBeforeDeleteHooks, itemHook)
		itemBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		itemAfterDeleteMu.Lock()
		itemAfterDeleteHooks = append(itemAfterDeleteHooks, itemHook)
		itemAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		itemBeforeUpsertMu.Lock()
		itemBeforeUpsertHooks = append(itemBeforeUpsertHooks, itemHook)
		itemBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		itemAfterUpsertMu.Lock()
		itemAfterUpsertHooks = append(itemAfterUpsertHooks, itemHook)
		itemAfterUpsertMu.Unlock()
	}
}

// OneG returns a single item record from the query using the global executor.
func (q itemQuery) OneG(ctx context.Context) (*Item, error) {
	return q.One(ctx, boil.GetContextDB())
}

// OneGP returns a single item record from the query using the global executor, and panics on error.
func (q itemQuery) OneGP(ctx context.Context) *Item {
	o, err := q.One(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single item record from the query, and panics on error.
func (q itemQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *Item {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single item record from the query.
func (q itemQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Item, error) {
	o := &Item{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: failed to execute a one query for items")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Item records from the query using the global executor.
func (q itemQuery) AllG(ctx context.Context) (ItemSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// AllGP returns all Item records from the query using the global executor, and panics on error.
func (q itemQuery) AllGP(ctx context.Context) ItemSlice {
	o, err := q.All(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all Item records from the query, and panics on error.
func (q itemQuery) AllP(ctx context.Context, exec boil.ContextExecutor) ItemSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all Item records from the query.
func (q itemQuery) All(ctx context.Context, exec boil.ContextExecutor) (ItemSlice, error) {
	var o []*Item

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "game_config: failed to assign all query results to Item slice")
	}

	if len(itemAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Item records in the query using the global executor
func (q itemQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// CountGP returns the count of all Item records in the query using the global executor, and panics on error.
func (q itemQuery) CountGP(ctx context.Context) int64 {
	c, err := q.Count(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all Item records in the query, and panics on error.
func (q itemQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all Item records in the query.
func (q itemQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to count items rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q itemQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q itemQuery) ExistsGP(ctx context.Context) bool {
	e, err := q.Exists(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q itemQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q itemQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "game_config: failed to check if items exists")
	}

	return count > 0, nil
}

// EnhancementMaterial pointed to by the foreign key.
func (o *Item) EnhancementMaterial(mods ...qm.QueryMod) itemQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.EnhancementMaterialID),
	}

	queryMods = append(queryMods, mods...)

	return Items(queryMods...)
}

// Set pointed to by the foreign key.
func (o *Item) Set(mods ...qm.QueryMod) equipmentSetConfigQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SetID),
	}

	queryMods = append(queryMods, mods...)

	return EquipmentSetConfigs(queryMods...)
}

// DropPoolItems retrieves all the drop_pool_item's DropPoolItems with an executor.
func (o *Item) DropPoolItems(mods ...qm.QueryMod) dropPoolItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"drop_pool_items\".\"item_id\"=?", o.ID),
	)

	return DropPoolItems(queryMods...)
}

// ItemClassRelations retrieves all the item_class_relation's ItemClassRelations with an executor.
func (o *Item) ItemClassRelations(mods ...qm.QueryMod) itemClassRelationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"item_class_relations\".\"item_id\"=?", o.ID),
	)

	return ItemClassRelations(queryMods...)
}

// EnhancementMaterialItems retrieves all the item's Items with an executor via enhancement_material_id column.
func (o *Item) EnhancementMaterialItems(mods ...qm.QueryMod) itemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"items\".\"enhancement_material_id\"=?", o.ID),
	)

	return Items(queryMods...)
}

// WorldDropConfigs retrieves all the world_drop_config's WorldDropConfigs with an executor.
func (o *Item) WorldDropConfigs(mods ...qm.QueryMod) worldDropConfigQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"world_drop_configs\".\"item_id\"=?", o.ID),
	)

	return WorldDropConfigs(queryMods...)
}

// LoadEnhancementMaterial allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (itemL) LoadEnhancementMaterial(ctx context.Context, e boil.ContextExecutor, singular bool, maybeItem interface{}, mods queries.Applicator) error {
	var slice []*Item
	var object *Item

	if singular {
		var ok bool
		object, ok = maybeItem.(*Item)
		if !ok {
			object = new(Item)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeItem))
			}
		}
	} else {
		s, ok := maybeItem.(*[]*Item)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeItem))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &itemR{}
		}
		if !queries.IsNil(object.EnhancementMaterialID) {
			args[object.EnhancementMaterialID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemR{}
			}

			if !queries.IsNil(obj.EnhancementMaterialID) {
				args[obj.EnhancementMaterialID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.items`),
		qm.WhereIn(`game_config.items.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.items.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Item")
	}

	var resultSlice []*Item
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for items")
	}

	if len(itemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.EnhancementMaterial = foreign
		if foreign.R == nil {
			foreign.R = &itemR{}
		}
		foreign.R.EnhancementMaterialItems = append(foreign.R.EnhancementMaterialItems, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.EnhancementMaterialID, foreign.ID) {
				local.R.EnhancementMaterial = foreign
				if foreign.R == nil {
					foreign.R = &itemR{}
				}
				foreign.R.EnhancementMaterialItems = append(foreign.R.EnhancementMaterialItems, local)
				break
			}
		}
	}

	return nil
}

// LoadSet allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (itemL) LoadSet(ctx context.Context, e boil.ContextExecutor, singular bool, maybeItem interface{}, mods queries.Applicator) error {
	var slice []*Item
	var object *Item

	if singular {
		var ok bool
		object, ok = maybeItem.(*Item)
		if !ok {
			object = new(Item)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeItem))
			}
		}
	} else {
		s, ok := maybeItem.(*[]*Item)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeItem))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &itemR{}
		}
		if !queries.IsNil(object.SetID) {
			args[object.SetID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemR{}
			}

			if !queries.IsNil(obj.SetID) {
				args[obj.SetID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.equipment_set_configs`),
		qm.WhereIn(`game_config.equipment_set_configs.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.equipment_set_configs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load EquipmentSetConfig")
	}

	var resultSlice []*EquipmentSetConfig
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice EquipmentSetConfig")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for equipment_set_configs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for equipment_set_configs")
	}

	if len(equipmentSetConfigAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Set = foreign
		if foreign.R == nil {
			foreign.R = &equipmentSetConfigR{}
		}
		foreign.R.SetItems = append(foreign.R.SetItems, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SetID, foreign.ID) {
				local.R.Set = foreign
				if foreign.R == nil {
					foreign.R = &equipmentSetConfigR{}
				}
				foreign.R.SetItems = append(foreign.R.SetItems, local)
				break
			}
		}
	}

	return nil
}

// LoadDropPoolItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (itemL) LoadDropPoolItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeItem interface{}, mods queries.Applicator) error {
	var slice []*Item
	var object *Item

	if singular {
		var ok bool
		object, ok = maybeItem.(*Item)
		if !ok {
			object = new(Item)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeItem))
			}
		}
	} else {
		s, ok := maybeItem.(*[]*Item)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeItem))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &itemR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.drop_pool_items`),
		qm.WhereIn(`game_config.drop_pool_items.item_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.drop_pool_items.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load drop_pool_items")
	}

	var resultSlice []*DropPoolItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice drop_pool_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on drop_pool_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for drop_pool_items")
	}

	if len(dropPoolItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DropPoolItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dropPoolItemR{}
			}
			foreign.R.Item = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ItemID {
				local.R.DropPoolItems = append(local.R.DropPoolItems, foreign)
				if foreign.R == nil {
					foreign.R = &dropPoolItemR{}
				}
				foreign.R.Item = local
				break
			}
		}
	}

	return nil
}

// LoadItemClassRelations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (itemL) LoadItemClassRelations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeItem interface{}, mods queries.Applicator) error {
	var slice []*Item
	var object *Item

	if singular {
		var ok bool
		object, ok = maybeItem.(*Item)
		if !ok {
			object = new(Item)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeItem))
			}
		}
	} else {
		s, ok := maybeItem.(*[]*Item)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeItem))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &itemR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.item_class_relations`),
		qm.WhereIn(`game_config.item_class_relations.item_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_class_relations")
	}

	var resultSlice []*ItemClassRelation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_class_relations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_class_relations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_class_relations")
	}

	if len(itemClassRelationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ItemClassRelations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemClassRelationR{}
			}
			foreign.R.Item = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ItemID {
				local.R.ItemClassRelations = append(local.R.ItemClassRelations, foreign)
				if foreign.R == nil {
					foreign.R = &itemClassRelationR{}
				}
				foreign.R.Item = local
				break
			}
		}
	}

	return nil
}

// LoadEnhancementMaterialItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (itemL) LoadEnhancementMaterialItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeItem interface{}, mods queries.Applicator) error {
	var slice []*Item
	var object *Item

	if singular {
		var ok bool
		object, ok = maybeItem.(*Item)
		if !ok {
			object = new(Item)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeItem))
			}
		}
	} else {
		s, ok := maybeItem.(*[]*Item)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeItem))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &itemR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.items`),
		qm.WhereIn(`game_config.items.enhancement_material_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.items.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load items")
	}

	var resultSlice []*Item
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for items")
	}

	if len(itemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EnhancementMaterialItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemR{}
			}
			foreign.R.EnhancementMaterial = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.EnhancementMaterialID) {
				local.R.EnhancementMaterialItems = append(local.R.EnhancementMaterialItems, foreign)
				if foreign.R == nil {
					foreign.R = &itemR{}
				}
				foreign.R.EnhancementMaterial = local
				break
			}
		}
	}

	return nil
}

// LoadWorldDropConfigs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (itemL) LoadWorldDropConfigs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeItem interface{}, mods queries.Applicator) error {
	var slice []*Item
	var object *Item

	if singular {
		var ok bool
		object, ok = maybeItem.(*Item)
		if !ok {
			object = new(Item)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeItem))
			}
		}
	} else {
		s, ok := maybeItem.(*[]*Item)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeItem)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeItem))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &itemR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.world_drop_configs`),
		qm.WhereIn(`game_config.world_drop_configs.item_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.world_drop_configs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load world_drop_configs")
	}

	var resultSlice []*WorldDropConfig
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice world_drop_configs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on world_drop_configs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for world_drop_configs")
	}

	if len(worldDropConfigAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.WorldDropConfigs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &worldDropConfigR{}
			}
			foreign.R.Item = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ItemID {
				local.R.WorldDropConfigs = append(local.R.WorldDropConfigs, foreign)
				if foreign.R == nil {
					foreign.R = &worldDropConfigR{}
				}
				foreign.R.Item = local
				break
			}
		}
	}

	return nil
}

// SetEnhancementMaterialG of the item to the related item.
// Sets o.R.EnhancementMaterial to related.
// Adds o to related.R.EnhancementMaterialItems.
// Uses the global database handle.
func (o *Item) SetEnhancementMaterialG(ctx context.Context, insert bool, related *Item) error {
	return o.SetEnhancementMaterial(ctx, boil.GetContextDB(), insert, related)
}

// SetEnhancementMaterialP of the item to the related item.
// Sets o.R.EnhancementMaterial to related.
// Adds o to related.R.EnhancementMaterialItems.
// Panics on error.
func (o *Item) SetEnhancementMaterialP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Item) {
	if err := o.SetEnhancementMaterial(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetEnhancementMaterialGP of the item to the related item.
// Sets o.R.EnhancementMaterial to related.
// Adds o to related.R.EnhancementMaterialItems.
// Uses the global database handle and panics on error.
func (o *Item) SetEnhancementMaterialGP(ctx context.Context, insert bool, related *Item) {
	if err := o.SetEnhancementMaterial(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetEnhancementMaterial of the item to the related item.
// Sets o.R.EnhancementMaterial to related.
// Adds o to related.R.EnhancementMaterialItems.
func (o *Item) SetEnhancementMaterial(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Item) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"items\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"enhancement_material_id"}),
		strmangle.WhereClause("\"", "\"", 2, itemPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.EnhancementMaterialID, related.ID)
	if o.R == nil {
		o.R = &itemR{
			EnhancementMaterial: related,
		}
	} else {
		o.R.EnhancementMaterial = related
	}

	if related.R == nil {
		related.R = &itemR{
			EnhancementMaterialItems: ItemSlice{o},
		}
	} else {
		related.R.EnhancementMaterialItems = append(related.R.EnhancementMaterialItems, o)
	}

	return nil
}

// RemoveEnhancementMaterialG relationship.
// Sets o.R.EnhancementMaterial to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Item) RemoveEnhancementMaterialG(ctx context.Context, related *Item) error {
	return o.RemoveEnhancementMaterial(ctx, boil.GetContextDB(), related)
}

// RemoveEnhancementMaterialP relationship.
// Sets o.R.EnhancementMaterial to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Item) RemoveEnhancementMaterialP(ctx context.Context, exec boil.ContextExecutor, related *Item) {
	if err := o.RemoveEnhancementMaterial(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveEnhancementMaterialGP relationship.
// Sets o.R.EnhancementMaterial to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Item) RemoveEnhancementMaterialGP(ctx context.Context, related *Item) {
	if err := o.RemoveEnhancementMaterial(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveEnhancementMaterial relationship.
// Sets o.R.EnhancementMaterial to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Item) RemoveEnhancementMaterial(ctx context.Context, exec boil.ContextExecutor, related *Item) error {
	var err error

	queries.SetScanner(&o.EnhancementMaterialID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("enhancement_material_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.EnhancementMaterial = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.EnhancementMaterialItems {
		if queries.Equal(o.EnhancementMaterialID, ri.EnhancementMaterialID) {
			continue
		}

		ln := len(related.R.EnhancementMaterialItems)
		if ln > 1 && i < ln-1 {
			related.R.EnhancementMaterialItems[i] = related.R.EnhancementMaterialItems[ln-1]
		}
		related.R.EnhancementMaterialItems = related.R.EnhancementMaterialItems[:ln-1]
		break
	}
	return nil
}

// SetSetG of the item to the related item.
// Sets o.R.Set to related.
// Adds o to related.R.SetItems.
// Uses the global database handle.
func (o *Item) SetSetG(ctx context.Context, insert bool, related *EquipmentSetConfig) error {
	return o.SetSet(ctx, boil.GetContextDB(), insert, related)
}

// SetSetP of the item to the related item.
// Sets o.R.Set to related.
// Adds o to related.R.SetItems.
// Panics on error.
func (o *Item) SetSetP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *EquipmentSetConfig) {
	if err := o.SetSet(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetSetGP of the item to the related item.
// Sets o.R.Set to related.
// Adds o to related.R.SetItems.
// Uses the global database handle and panics on error.
func (o *Item) SetSetGP(ctx context.Context, insert bool, related *EquipmentSetConfig) {
	if err := o.SetSet(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetSet of the item to the related item.
// Sets o.R.Set to related.
// Adds o to related.R.SetItems.
func (o *Item) SetSet(ctx context.Context, exec boil.ContextExecutor, insert bool, related *EquipmentSetConfig) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"items\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"set_id"}),
		strmangle.WhereClause("\"", "\"", 2, itemPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SetID, related.ID)
	if o.R == nil {
		o.R = &itemR{
			Set: related,
		}
	} else {
		o.R.Set = related
	}

	if related.R == nil {
		related.R = &equipmentSetConfigR{
			SetItems: ItemSlice{o},
		}
	} else {
		related.R.SetItems = append(related.R.SetItems, o)
	}

	return nil
}

// RemoveSetG relationship.
// Sets o.R.Set to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Item) RemoveSetG(ctx context.Context, related *EquipmentSetConfig) error {
	return o.RemoveSet(ctx, boil.GetContextDB(), related)
}

// RemoveSetP relationship.
// Sets o.R.Set to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Item) RemoveSetP(ctx context.Context, exec boil.ContextExecutor, related *EquipmentSetConfig) {
	if err := o.RemoveSet(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveSetGP relationship.
// Sets o.R.Set to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Item) RemoveSetGP(ctx context.Context, related *EquipmentSetConfig) {
	if err := o.RemoveSet(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveSet relationship.
// Sets o.R.Set to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Item) RemoveSet(ctx context.Context, exec boil.ContextExecutor, related *EquipmentSetConfig) error {
	var err error

	queries.SetScanner(&o.SetID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("set_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Set = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SetItems {
		if queries.Equal(o.SetID, ri.SetID) {
			continue
		}

		ln := len(related.R.SetItems)
		if ln > 1 && i < ln-1 {
			related.R.SetItems[i] = related.R.SetItems[ln-1]
		}
		related.R.SetItems = related.R.SetItems[:ln-1]
		break
	}
	return nil
}

// AddDropPoolItemsG adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.DropPoolItems.
// Sets related.R.Item appropriately.
// Uses the global database handle.
func (o *Item) AddDropPoolItemsG(ctx context.Context, insert bool, related ...*DropPoolItem) error {
	return o.AddDropPoolItems(ctx, boil.GetContextDB(), insert, related...)
}

// AddDropPoolItemsP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.DropPoolItems.
// Sets related.R.Item appropriately.
// Panics on error.
func (o *Item) AddDropPoolItemsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DropPoolItem) {
	if err := o.AddDropPoolItems(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddDropPoolItemsGP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.DropPoolItems.
// Sets related.R.Item appropriately.
// Uses the global database handle and panics on error.
func (o *Item) AddDropPoolItemsGP(ctx context.Context, insert bool, related ...*DropPoolItem) {
	if err := o.AddDropPoolItems(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddDropPoolItems adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.DropPoolItems.
// Sets related.R.Item appropriately.
func (o *Item) AddDropPoolItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DropPoolItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ItemID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"drop_pool_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"item_id"}),
				strmangle.WhereClause("\"", "\"", 2, dropPoolItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ItemID = o.ID
		}
	}

	if o.R == nil {
		o.R = &itemR{
			DropPoolItems: related,
		}
	} else {
		o.R.DropPoolItems = append(o.R.DropPoolItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dropPoolItemR{
				Item: o,
			}
		} else {
			rel.R.Item = o
		}
	}
	return nil
}

// AddItemClassRelationsG adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.ItemClassRelations.
// Sets related.R.Item appropriately.
// Uses the global database handle.
func (o *Item) AddItemClassRelationsG(ctx context.Context, insert bool, related ...*ItemClassRelation) error {
	return o.AddItemClassRelations(ctx, boil.GetContextDB(), insert, related...)
}

// AddItemClassRelationsP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.ItemClassRelations.
// Sets related.R.Item appropriately.
// Panics on error.
func (o *Item) AddItemClassRelationsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ItemClassRelation) {
	if err := o.AddItemClassRelations(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddItemClassRelationsGP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.ItemClassRelations.
// Sets related.R.Item appropriately.
// Uses the global database handle and panics on error.
func (o *Item) AddItemClassRelationsGP(ctx context.Context, insert bool, related ...*ItemClassRelation) {
	if err := o.AddItemClassRelations(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddItemClassRelations adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.ItemClassRelations.
// Sets related.R.Item appropriately.
func (o *Item) AddItemClassRelations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ItemClassRelation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ItemID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"item_class_relations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"item_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemClassRelationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ItemID = o.ID
		}
	}

	if o.R == nil {
		o.R = &itemR{
			ItemClassRelations: related,
		}
	} else {
		o.R.ItemClassRelations = append(o.R.ItemClassRelations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemClassRelationR{
				Item: o,
			}
		} else {
			rel.R.Item = o
		}
	}
	return nil
}

// AddEnhancementMaterialItemsG adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.EnhancementMaterialItems.
// Sets related.R.EnhancementMaterial appropriately.
// Uses the global database handle.
func (o *Item) AddEnhancementMaterialItemsG(ctx context.Context, insert bool, related ...*Item) error {
	return o.AddEnhancementMaterialItems(ctx, boil.GetContextDB(), insert, related...)
}

// AddEnhancementMaterialItemsP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.EnhancementMaterialItems.
// Sets related.R.EnhancementMaterial appropriately.
// Panics on error.
func (o *Item) AddEnhancementMaterialItemsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Item) {
	if err := o.AddEnhancementMaterialItems(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddEnhancementMaterialItemsGP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.EnhancementMaterialItems.
// Sets related.R.EnhancementMaterial appropriately.
// Uses the global database handle and panics on error.
func (o *Item) AddEnhancementMaterialItemsGP(ctx context.Context, insert bool, related ...*Item) {
	if err := o.AddEnhancementMaterialItems(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddEnhancementMaterialItems adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.EnhancementMaterialItems.
// Sets related.R.EnhancementMaterial appropriately.
func (o *Item) AddEnhancementMaterialItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Item) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.EnhancementMaterialID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"enhancement_material_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.EnhancementMaterialID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &itemR{
			EnhancementMaterialItems: related,
		}
	} else {
		o.R.EnhancementMaterialItems = append(o.R.EnhancementMaterialItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemR{
				EnhancementMaterial: o,
			}
		} else {
			rel.R.EnhancementMaterial = o
		}
	}
	return nil
}

// SetEnhancementMaterialItemsG removes all previously related items of the
// item replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Replaces o.R.EnhancementMaterialItems with related.
// Sets related.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Uses the global database handle.
func (o *Item) SetEnhancementMaterialItemsG(ctx context.Context, insert bool, related ...*Item) error {
	return o.SetEnhancementMaterialItems(ctx, boil.GetContextDB(), insert, related...)
}

// SetEnhancementMaterialItemsP removes all previously related items of the
// item replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Replaces o.R.EnhancementMaterialItems with related.
// Sets related.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Panics on error.
func (o *Item) SetEnhancementMaterialItemsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Item) {
	if err := o.SetEnhancementMaterialItems(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetEnhancementMaterialItemsGP removes all previously related items of the
// item replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Replaces o.R.EnhancementMaterialItems with related.
// Sets related.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Uses the global database handle and panics on error.
func (o *Item) SetEnhancementMaterialItemsGP(ctx context.Context, insert bool, related ...*Item) {
	if err := o.SetEnhancementMaterialItems(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetEnhancementMaterialItems removes all previously related items of the
// item replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
// Replaces o.R.EnhancementMaterialItems with related.
// Sets related.R.EnhancementMaterial's EnhancementMaterialItems accordingly.
func (o *Item) SetEnhancementMaterialItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Item) error {
	query := "update \"game_config\".\"items\" set \"enhancement_material_id\" = null where \"enhancement_material_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.EnhancementMaterialItems {
			queries.SetScanner(&rel.EnhancementMaterialID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.EnhancementMaterial = nil
		}
		o.R.EnhancementMaterialItems = nil
	}

	return o.AddEnhancementMaterialItems(ctx, exec, insert, related...)
}

// RemoveEnhancementMaterialItemsG relationships from objects passed in.
// Removes related items from R.EnhancementMaterialItems (uses pointer comparison, removal does not keep order)
// Sets related.R.EnhancementMaterial.
// Uses the global database handle.
func (o *Item) RemoveEnhancementMaterialItemsG(ctx context.Context, related ...*Item) error {
	return o.RemoveEnhancementMaterialItems(ctx, boil.GetContextDB(), related...)
}

// RemoveEnhancementMaterialItemsP relationships from objects passed in.
// Removes related items from R.EnhancementMaterialItems (uses pointer comparison, removal does not keep order)
// Sets related.R.EnhancementMaterial.
// Panics on error.
func (o *Item) RemoveEnhancementMaterialItemsP(ctx context.Context, exec boil.ContextExecutor, related ...*Item) {
	if err := o.RemoveEnhancementMaterialItems(ctx, exec, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveEnhancementMaterialItemsGP relationships from objects passed in.
// Removes related items from R.EnhancementMaterialItems (uses pointer comparison, removal does not keep order)
// Sets related.R.EnhancementMaterial.
// Uses the global database handle and panics on error.
func (o *Item) RemoveEnhancementMaterialItemsGP(ctx context.Context, related ...*Item) {
	if err := o.RemoveEnhancementMaterialItems(ctx, boil.GetContextDB(), related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveEnhancementMaterialItems relationships from objects passed in.
// Removes related items from R.EnhancementMaterialItems (uses pointer comparison, removal does not keep order)
// Sets related.R.EnhancementMaterial.
func (o *Item) RemoveEnhancementMaterialItems(ctx context.Context, exec boil.ContextExecutor, related ...*Item) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.EnhancementMaterialID, nil)
		if rel.R != nil {
			rel.R.EnhancementMaterial = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("enhancement_material_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.EnhancementMaterialItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.EnhancementMaterialItems)
			if ln > 1 && i < ln-1 {
				o.R.EnhancementMaterialItems[i] = o.R.EnhancementMaterialItems[ln-1]
			}
			o.R.EnhancementMaterialItems = o.R.EnhancementMaterialItems[:ln-1]
			break
		}
	}

	return nil
}

// AddWorldDropConfigsG adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.WorldDropConfigs.
// Sets related.R.Item appropriately.
// Uses the global database handle.
func (o *Item) AddWorldDropConfigsG(ctx context.Context, insert bool, related ...*WorldDropConfig) error {
	return o.AddWorldDropConfigs(ctx, boil.GetContextDB(), insert, related...)
}

// AddWorldDropConfigsP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.WorldDropConfigs.
// Sets related.R.Item appropriately.
// Panics on error.
func (o *Item) AddWorldDropConfigsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WorldDropConfig) {
	if err := o.AddWorldDropConfigs(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddWorldDropConfigsGP adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.WorldDropConfigs.
// Sets related.R.Item appropriately.
// Uses the global database handle and panics on error.
func (o *Item) AddWorldDropConfigsGP(ctx context.Context, insert bool, related ...*WorldDropConfig) {
	if err := o.AddWorldDropConfigs(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddWorldDropConfigs adds the given related objects to the existing relationships
// of the item, optionally inserting them as new records.
// Appends related to o.R.WorldDropConfigs.
// Sets related.R.Item appropriately.
func (o *Item) AddWorldDropConfigs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WorldDropConfig) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ItemID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"world_drop_configs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"item_id"}),
				strmangle.WhereClause("\"", "\"", 2, worldDropConfigPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ItemID = o.ID
		}
	}

	if o.R == nil {
		o.R = &itemR{
			WorldDropConfigs: related,
		}
	} else {
		o.R.WorldDropConfigs = append(o.R.WorldDropConfigs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &worldDropConfigR{
				Item: o,
			}
		} else {
			rel.R.Item = o
		}
	}
	return nil
}

// Items retrieves all the records using an executor.
func Items(mods ...qm.QueryMod) itemQuery {
	mods = append(mods, qm.From("\"game_config\".\"items\""), qmhelper.WhereIsNull("\"game_config\".\"items\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_config\".\"items\".*"})
	}

	return itemQuery{q}
}

// FindItemG retrieves a single record by ID.
func FindItemG(ctx context.Context, iD string, selectCols ...string) (*Item, error) {
	return FindItem(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindItemP retrieves a single record by ID with an executor, and panics on error.
func FindItemP(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) *Item {
	retobj, err := FindItem(ctx, exec, iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindItemGP retrieves a single record by ID, and panics on error.
func FindItemGP(ctx context.Context, iD string, selectCols ...string) *Item {
	retobj, err := FindItem(ctx, boil.GetContextDB(), iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindItem retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindItem(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Item, error) {
	itemObj := &Item{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_config\".\"items\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, itemObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: unable to select from items")
	}

	if err = itemObj.doAfterSelectHooks(ctx, exec); err != nil {
		return itemObj, err
	}

	return itemObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Item) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *Item) InsertP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) {
	if err := o.Insert(ctx, exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *Item) InsertGP(ctx context.Context, columns boil.Columns) {
	if err := o.Insert(ctx, boil.GetContextDB(), columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Item) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("game_config: no items provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(itemColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	itemInsertCacheMut.RLock()
	cache, cached := itemInsertCache[key]
	itemInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			itemAllColumns,
			itemColumnsWithDefault,
			itemColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(itemType, itemMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(itemType, itemMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_config\".\"items\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_config\".\"items\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "game_config: unable to insert into items")
	}

	if !cached {
		itemInsertCacheMut.Lock()
		itemInsertCache[key] = cache
		itemInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Item record using the global executor.
// See Update for more documentation.
func (o *Item) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// UpdateP uses an executor to update the Item, and panics on error.
// See Update for more documentation.
func (o *Item) UpdateP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateGP a single Item record using the global executor. Panics on error.
// See Update for more documentation.
func (o *Item) UpdateGP(ctx context.Context, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, boil.GetContextDB(), columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Update uses an executor to update the Item.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Item) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	itemUpdateCacheMut.RLock()
	cache, cached := itemUpdateCache[key]
	itemUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			itemAllColumns,
			itemPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("game_config: unable to update items, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_config\".\"items\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, itemPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(itemType, itemMapping, append(wl, itemPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update items row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by update for items")
	}

	if !cached {
		itemUpdateCacheMut.Lock()
		itemUpdateCache[key] = cache
		itemUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q itemQuery) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllG updates all rows with the specified column values.
func (q itemQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (q itemQuery) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values.
func (q itemQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all for items")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected for items")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ItemSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o ItemSlice) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o ItemSlice) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ItemSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("game_config: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_config\".\"items\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, itemPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all in item slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected all in update all item")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Item) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *Item) UpsertGP(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *Item) UpsertP(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, exec, updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Item) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("game_config: no items provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(itemColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	itemUpsertCacheMut.RLock()
	cache, cached := itemUpsertCache[key]
	itemUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			itemAllColumns,
			itemColumnsWithDefault,
			itemColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			itemAllColumns,
			itemPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("game_config: unable to upsert items, could not build update column list")
		}

		ret := strmangle.SetComplement(itemAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(itemPrimaryKeyColumns) == 0 {
				return errors.New("game_config: unable to upsert items, could not build conflict column list")
			}

			conflict = make([]string, len(itemPrimaryKeyColumns))
			copy(conflict, itemPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_config\".\"items\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(itemType, itemMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(itemType, itemMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "game_config: unable to upsert items")
	}

	if !cached {
		itemUpsertCacheMut.Lock()
		itemUpsertCache[key] = cache
		itemUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Item record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Item) DeleteG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteP deletes a single Item record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Item) DeleteP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteGP deletes a single Item record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Item) DeleteGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Delete deletes a single Item record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Item) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("game_config: no Item provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), itemPrimaryKeyMapping)
		sql = "DELETE FROM \"game_config\".\"items\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"items\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(itemType, itemMapping, append(wl, itemPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete from items")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by delete for items")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q itemQuery) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows, and panics on error.
func (q itemQuery) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows, and panics on error.
func (q itemQuery) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all matching rows.
func (q itemQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("game_config: no itemQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from items")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for items")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ItemSlice) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o ItemSlice) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o ItemSlice) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ItemSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(itemBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"game_config\".\"items\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, itemPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"items\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, itemPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from item slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for items")
	}

	if len(itemAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Item) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: no Item provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *Item) ReloadP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.Reload(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadGP refetches the object from the database and panics on error.
func (o *Item) ReloadGP(ctx context.Context) {
	if err := o.Reload(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Item) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindItem(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ItemSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: empty ItemSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *ItemSlice) ReloadAllP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.ReloadAll(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *ItemSlice) ReloadAllGP(ctx context.Context) {
	if err := o.ReloadAll(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ItemSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ItemSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_config\".\"items\".* FROM \"game_config\".\"items\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, itemPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "game_config: unable to reload all in ItemSlice")
	}

	*o = slice

	return nil
}

// ItemExistsG checks if the Item row exists.
func ItemExistsG(ctx context.Context, iD string) (bool, error) {
	return ItemExists(ctx, boil.GetContextDB(), iD)
}

// ItemExistsP checks if the Item row exists. Panics on error.
func ItemExistsP(ctx context.Context, exec boil.ContextExecutor, iD string) bool {
	e, err := ItemExists(ctx, exec, iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ItemExistsGP checks if the Item row exists. Panics on error.
func ItemExistsGP(ctx context.Context, iD string) bool {
	e, err := ItemExists(ctx, boil.GetContextDB(), iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ItemExists checks if the Item row exists.
func ItemExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_config\".\"items\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "game_config: unable to check if items exists")
	}

	return exists, nil
}

// Exists checks if the Item row exists.
func (o *Item) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ItemExists(ctx, exec, o.ID)
}
