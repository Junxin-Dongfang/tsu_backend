// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package game_config

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Monster is an object representing the database table.
type Monster struct {
	ID string `boil:"id" json:"id" toml:"id" yaml:"id"`
	// 怪物代码（唯一标识）
	MonsterCode string `boil:"monster_code" json:"monster_code" toml:"monster_code" yaml:"monster_code"`
	// 怪物名称
	MonsterName string `boil:"monster_name" json:"monster_name" toml:"monster_name" yaml:"monster_name"`
	// 怪物等级（1-100）
	MonsterLevel int16       `boil:"monster_level" json:"monster_level" toml:"monster_level" yaml:"monster_level"`
	Description  null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	MaxHP        int         `boil:"max_hp" json:"max_hp" toml:"max_hp" yaml:"max_hp"`
	HPRecovery   null.Int    `boil:"hp_recovery" json:"hp_recovery,omitempty" toml:"hp_recovery" yaml:"hp_recovery,omitempty"`
	MaxMP        null.Int    `boil:"max_mp" json:"max_mp,omitempty" toml:"max_mp" yaml:"max_mp,omitempty"`
	MPRecovery   null.Int    `boil:"mp_recovery" json:"mp_recovery,omitempty" toml:"mp_recovery" yaml:"mp_recovery,omitempty"`
	BaseSTR      null.Int16  `boil:"base_str" json:"base_str,omitempty" toml:"base_str" yaml:"base_str,omitempty"`
	BaseAgi      null.Int16  `boil:"base_agi" json:"base_agi,omitempty" toml:"base_agi" yaml:"base_agi,omitempty"`
	BaseVit      null.Int16  `boil:"base_vit" json:"base_vit,omitempty" toml:"base_vit" yaml:"base_vit,omitempty"`
	BaseWLP      null.Int16  `boil:"base_wlp" json:"base_wlp,omitempty" toml:"base_wlp" yaml:"base_wlp,omitempty"`
	BaseInt      null.Int16  `boil:"base_int" json:"base_int,omitempty" toml:"base_int" yaml:"base_int,omitempty"`
	BaseWis      null.Int16  `boil:"base_wis" json:"base_wis,omitempty" toml:"base_wis" yaml:"base_wis,omitempty"`
	BaseCha      null.Int16  `boil:"base_cha" json:"base_cha,omitempty" toml:"base_cha" yaml:"base_cha,omitempty"`
	// 精准属性类型代码（引用 hero_attribute_type，决定命中率计算公式）
	AccuracyAttributeCode null.String `boil:"accuracy_attribute_code" json:"accuracy_attribute_code,omitempty" toml:"accuracy_attribute_code" yaml:"accuracy_attribute_code,omitempty"`
	// 闪避属性类型代码（引用 hero_attribute_type，决定闪避率计算公式）
	DodgeAttributeCode null.String `boil:"dodge_attribute_code" json:"dodge_attribute_code,omitempty" toml:"dodge_attribute_code" yaml:"dodge_attribute_code,omitempty"`
	// 先攻属性类型代码（引用 hero_attribute_type，决定行动顺序计算公式）
	InitiativeAttributeCode null.String `boil:"initiative_attribute_code" json:"initiative_attribute_code,omitempty" toml:"initiative_attribute_code" yaml:"initiative_attribute_code,omitempty"`
	// 体质豁免属性类型代码（引用 hero_attribute_type，决定抗毒素等计算公式）
	BodyResistAttributeCode null.String `boil:"body_resist_attribute_code" json:"body_resist_attribute_code,omitempty" toml:"body_resist_attribute_code" yaml:"body_resist_attribute_code,omitempty"`
	// 魔法豁免属性类型代码（引用 hero_attribute_type，决定抗魔法计算公式）
	MagicResistAttributeCode null.String `boil:"magic_resist_attribute_code" json:"magic_resist_attribute_code,omitempty" toml:"magic_resist_attribute_code" yaml:"magic_resist_attribute_code,omitempty"`
	// 精神豁免属性类型代码（引用 hero_attribute_type，决定抗精神控制计算公式）
	MentalResistAttributeCode null.String `boil:"mental_resist_attribute_code" json:"mental_resist_attribute_code,omitempty" toml:"mental_resist_attribute_code" yaml:"mental_resist_attribute_code,omitempty"`
	// 环境豁免属性类型代码（引用 hero_attribute_type，决定抗环境伤害计算公式）
	EnvironmentResistAttributeCode null.String `boil:"environment_resist_attribute_code" json:"environment_resist_attribute_code,omitempty" toml:"environment_resist_attribute_code" yaml:"environment_resist_attribute_code,omitempty"`
	// 伤害抗性配置（JSONB格式）
	DamageResistances null.JSON `boil:"damage_resistances" json:"damage_resistances,omitempty" toml:"damage_resistances" yaml:"damage_resistances,omitempty"`
	// 被动效果列表（JSONB格式）
	PassiveBuffs null.JSON   `boil:"passive_buffs" json:"passive_buffs,omitempty" toml:"passive_buffs" yaml:"passive_buffs,omitempty"`
	DropGoldMin  null.Int    `boil:"drop_gold_min" json:"drop_gold_min,omitempty" toml:"drop_gold_min" yaml:"drop_gold_min,omitempty"`
	DropGoldMax  null.Int    `boil:"drop_gold_max" json:"drop_gold_max,omitempty" toml:"drop_gold_max" yaml:"drop_gold_max,omitempty"`
	DropExp      null.Int    `boil:"drop_exp" json:"drop_exp,omitempty" toml:"drop_exp" yaml:"drop_exp,omitempty"`
	IconURL      null.String `boil:"icon_url" json:"icon_url,omitempty" toml:"icon_url" yaml:"icon_url,omitempty"`
	ModelURL     null.String `boil:"model_url" json:"model_url,omitempty" toml:"model_url" yaml:"model_url,omitempty"`
	IsActive     null.Bool   `boil:"is_active" json:"is_active,omitempty" toml:"is_active" yaml:"is_active,omitempty"`
	DisplayOrder null.Int    `boil:"display_order" json:"display_order,omitempty" toml:"display_order" yaml:"display_order,omitempty"`
	CreatedAt    time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt    time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt    null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *monsterR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L monsterL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MonsterColumns = struct {
	ID                             string
	MonsterCode                    string
	MonsterName                    string
	MonsterLevel                   string
	Description                    string
	MaxHP                          string
	HPRecovery                     string
	MaxMP                          string
	MPRecovery                     string
	BaseSTR                        string
	BaseAgi                        string
	BaseVit                        string
	BaseWLP                        string
	BaseInt                        string
	BaseWis                        string
	BaseCha                        string
	AccuracyAttributeCode          string
	DodgeAttributeCode             string
	InitiativeAttributeCode        string
	BodyResistAttributeCode        string
	MagicResistAttributeCode       string
	MentalResistAttributeCode      string
	EnvironmentResistAttributeCode string
	DamageResistances              string
	PassiveBuffs                   string
	DropGoldMin                    string
	DropGoldMax                    string
	DropExp                        string
	IconURL                        string
	ModelURL                       string
	IsActive                       string
	DisplayOrder                   string
	CreatedAt                      string
	UpdatedAt                      string
	DeletedAt                      string
}{
	ID:                             "id",
	MonsterCode:                    "monster_code",
	MonsterName:                    "monster_name",
	MonsterLevel:                   "monster_level",
	Description:                    "description",
	MaxHP:                          "max_hp",
	HPRecovery:                     "hp_recovery",
	MaxMP:                          "max_mp",
	MPRecovery:                     "mp_recovery",
	BaseSTR:                        "base_str",
	BaseAgi:                        "base_agi",
	BaseVit:                        "base_vit",
	BaseWLP:                        "base_wlp",
	BaseInt:                        "base_int",
	BaseWis:                        "base_wis",
	BaseCha:                        "base_cha",
	AccuracyAttributeCode:          "accuracy_attribute_code",
	DodgeAttributeCode:             "dodge_attribute_code",
	InitiativeAttributeCode:        "initiative_attribute_code",
	BodyResistAttributeCode:        "body_resist_attribute_code",
	MagicResistAttributeCode:       "magic_resist_attribute_code",
	MentalResistAttributeCode:      "mental_resist_attribute_code",
	EnvironmentResistAttributeCode: "environment_resist_attribute_code",
	DamageResistances:              "damage_resistances",
	PassiveBuffs:                   "passive_buffs",
	DropGoldMin:                    "drop_gold_min",
	DropGoldMax:                    "drop_gold_max",
	DropExp:                        "drop_exp",
	IconURL:                        "icon_url",
	ModelURL:                       "model_url",
	IsActive:                       "is_active",
	DisplayOrder:                   "display_order",
	CreatedAt:                      "created_at",
	UpdatedAt:                      "updated_at",
	DeletedAt:                      "deleted_at",
}

var MonsterTableColumns = struct {
	ID                             string
	MonsterCode                    string
	MonsterName                    string
	MonsterLevel                   string
	Description                    string
	MaxHP                          string
	HPRecovery                     string
	MaxMP                          string
	MPRecovery                     string
	BaseSTR                        string
	BaseAgi                        string
	BaseVit                        string
	BaseWLP                        string
	BaseInt                        string
	BaseWis                        string
	BaseCha                        string
	AccuracyAttributeCode          string
	DodgeAttributeCode             string
	InitiativeAttributeCode        string
	BodyResistAttributeCode        string
	MagicResistAttributeCode       string
	MentalResistAttributeCode      string
	EnvironmentResistAttributeCode string
	DamageResistances              string
	PassiveBuffs                   string
	DropGoldMin                    string
	DropGoldMax                    string
	DropExp                        string
	IconURL                        string
	ModelURL                       string
	IsActive                       string
	DisplayOrder                   string
	CreatedAt                      string
	UpdatedAt                      string
	DeletedAt                      string
}{
	ID:                             "monsters.id",
	MonsterCode:                    "monsters.monster_code",
	MonsterName:                    "monsters.monster_name",
	MonsterLevel:                   "monsters.monster_level",
	Description:                    "monsters.description",
	MaxHP:                          "monsters.max_hp",
	HPRecovery:                     "monsters.hp_recovery",
	MaxMP:                          "monsters.max_mp",
	MPRecovery:                     "monsters.mp_recovery",
	BaseSTR:                        "monsters.base_str",
	BaseAgi:                        "monsters.base_agi",
	BaseVit:                        "monsters.base_vit",
	BaseWLP:                        "monsters.base_wlp",
	BaseInt:                        "monsters.base_int",
	BaseWis:                        "monsters.base_wis",
	BaseCha:                        "monsters.base_cha",
	AccuracyAttributeCode:          "monsters.accuracy_attribute_code",
	DodgeAttributeCode:             "monsters.dodge_attribute_code",
	InitiativeAttributeCode:        "monsters.initiative_attribute_code",
	BodyResistAttributeCode:        "monsters.body_resist_attribute_code",
	MagicResistAttributeCode:       "monsters.magic_resist_attribute_code",
	MentalResistAttributeCode:      "monsters.mental_resist_attribute_code",
	EnvironmentResistAttributeCode: "monsters.environment_resist_attribute_code",
	DamageResistances:              "monsters.damage_resistances",
	PassiveBuffs:                   "monsters.passive_buffs",
	DropGoldMin:                    "monsters.drop_gold_min",
	DropGoldMax:                    "monsters.drop_gold_max",
	DropExp:                        "monsters.drop_exp",
	IconURL:                        "monsters.icon_url",
	ModelURL:                       "monsters.model_url",
	IsActive:                       "monsters.is_active",
	DisplayOrder:                   "monsters.display_order",
	CreatedAt:                      "monsters.created_at",
	UpdatedAt:                      "monsters.updated_at",
	DeletedAt:                      "monsters.deleted_at",
}

// Generated where

var MonsterWhere = struct {
	ID                             whereHelperstring
	MonsterCode                    whereHelperstring
	MonsterName                    whereHelperstring
	MonsterLevel                   whereHelperint16
	Description                    whereHelpernull_String
	MaxHP                          whereHelperint
	HPRecovery                     whereHelpernull_Int
	MaxMP                          whereHelpernull_Int
	MPRecovery                     whereHelpernull_Int
	BaseSTR                        whereHelpernull_Int16
	BaseAgi                        whereHelpernull_Int16
	BaseVit                        whereHelpernull_Int16
	BaseWLP                        whereHelpernull_Int16
	BaseInt                        whereHelpernull_Int16
	BaseWis                        whereHelpernull_Int16
	BaseCha                        whereHelpernull_Int16
	AccuracyAttributeCode          whereHelpernull_String
	DodgeAttributeCode             whereHelpernull_String
	InitiativeAttributeCode        whereHelpernull_String
	BodyResistAttributeCode        whereHelpernull_String
	MagicResistAttributeCode       whereHelpernull_String
	MentalResistAttributeCode      whereHelpernull_String
	EnvironmentResistAttributeCode whereHelpernull_String
	DamageResistances              whereHelpernull_JSON
	PassiveBuffs                   whereHelpernull_JSON
	DropGoldMin                    whereHelpernull_Int
	DropGoldMax                    whereHelpernull_Int
	DropExp                        whereHelpernull_Int
	IconURL                        whereHelpernull_String
	ModelURL                       whereHelpernull_String
	IsActive                       whereHelpernull_Bool
	DisplayOrder                   whereHelpernull_Int
	CreatedAt                      whereHelpertime_Time
	UpdatedAt                      whereHelpertime_Time
	DeletedAt                      whereHelpernull_Time
}{
	ID:                             whereHelperstring{field: "\"game_config\".\"monsters\".\"id\""},
	MonsterCode:                    whereHelperstring{field: "\"game_config\".\"monsters\".\"monster_code\""},
	MonsterName:                    whereHelperstring{field: "\"game_config\".\"monsters\".\"monster_name\""},
	MonsterLevel:                   whereHelperint16{field: "\"game_config\".\"monsters\".\"monster_level\""},
	Description:                    whereHelpernull_String{field: "\"game_config\".\"monsters\".\"description\""},
	MaxHP:                          whereHelperint{field: "\"game_config\".\"monsters\".\"max_hp\""},
	HPRecovery:                     whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"hp_recovery\""},
	MaxMP:                          whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"max_mp\""},
	MPRecovery:                     whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"mp_recovery\""},
	BaseSTR:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_str\""},
	BaseAgi:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_agi\""},
	BaseVit:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_vit\""},
	BaseWLP:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_wlp\""},
	BaseInt:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_int\""},
	BaseWis:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_wis\""},
	BaseCha:                        whereHelpernull_Int16{field: "\"game_config\".\"monsters\".\"base_cha\""},
	AccuracyAttributeCode:          whereHelpernull_String{field: "\"game_config\".\"monsters\".\"accuracy_attribute_code\""},
	DodgeAttributeCode:             whereHelpernull_String{field: "\"game_config\".\"monsters\".\"dodge_attribute_code\""},
	InitiativeAttributeCode:        whereHelpernull_String{field: "\"game_config\".\"monsters\".\"initiative_attribute_code\""},
	BodyResistAttributeCode:        whereHelpernull_String{field: "\"game_config\".\"monsters\".\"body_resist_attribute_code\""},
	MagicResistAttributeCode:       whereHelpernull_String{field: "\"game_config\".\"monsters\".\"magic_resist_attribute_code\""},
	MentalResistAttributeCode:      whereHelpernull_String{field: "\"game_config\".\"monsters\".\"mental_resist_attribute_code\""},
	EnvironmentResistAttributeCode: whereHelpernull_String{field: "\"game_config\".\"monsters\".\"environment_resist_attribute_code\""},
	DamageResistances:              whereHelpernull_JSON{field: "\"game_config\".\"monsters\".\"damage_resistances\""},
	PassiveBuffs:                   whereHelpernull_JSON{field: "\"game_config\".\"monsters\".\"passive_buffs\""},
	DropGoldMin:                    whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"drop_gold_min\""},
	DropGoldMax:                    whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"drop_gold_max\""},
	DropExp:                        whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"drop_exp\""},
	IconURL:                        whereHelpernull_String{field: "\"game_config\".\"monsters\".\"icon_url\""},
	ModelURL:                       whereHelpernull_String{field: "\"game_config\".\"monsters\".\"model_url\""},
	IsActive:                       whereHelpernull_Bool{field: "\"game_config\".\"monsters\".\"is_active\""},
	DisplayOrder:                   whereHelpernull_Int{field: "\"game_config\".\"monsters\".\"display_order\""},
	CreatedAt:                      whereHelpertime_Time{field: "\"game_config\".\"monsters\".\"created_at\""},
	UpdatedAt:                      whereHelpertime_Time{field: "\"game_config\".\"monsters\".\"updated_at\""},
	DeletedAt:                      whereHelpernull_Time{field: "\"game_config\".\"monsters\".\"deleted_at\""},
}

// MonsterRels is where relationship names are stored.
var MonsterRels = struct {
	AccuracyAttributeCodeHeroAttributeType          string
	BodyResistAttributeCodeHeroAttributeType        string
	DodgeAttributeCodeHeroAttributeType             string
	EnvironmentResistAttributeCodeHeroAttributeType string
	InitiativeAttributeCodeHeroAttributeType        string
	MagicResistAttributeCodeHeroAttributeType       string
	MentalResistAttributeCodeHeroAttributeType      string
	MonsterDrops                                    string
	MonsterSkills                                   string
}{
	AccuracyAttributeCodeHeroAttributeType:          "AccuracyAttributeCodeHeroAttributeType",
	BodyResistAttributeCodeHeroAttributeType:        "BodyResistAttributeCodeHeroAttributeType",
	DodgeAttributeCodeHeroAttributeType:             "DodgeAttributeCodeHeroAttributeType",
	EnvironmentResistAttributeCodeHeroAttributeType: "EnvironmentResistAttributeCodeHeroAttributeType",
	InitiativeAttributeCodeHeroAttributeType:        "InitiativeAttributeCodeHeroAttributeType",
	MagicResistAttributeCodeHeroAttributeType:       "MagicResistAttributeCodeHeroAttributeType",
	MentalResistAttributeCodeHeroAttributeType:      "MentalResistAttributeCodeHeroAttributeType",
	MonsterDrops:  "MonsterDrops",
	MonsterSkills: "MonsterSkills",
}

// monsterR is where relationships are stored.
type monsterR struct {
	AccuracyAttributeCodeHeroAttributeType          *HeroAttributeType `boil:"AccuracyAttributeCodeHeroAttributeType" json:"AccuracyAttributeCodeHeroAttributeType" toml:"AccuracyAttributeCodeHeroAttributeType" yaml:"AccuracyAttributeCodeHeroAttributeType"`
	BodyResistAttributeCodeHeroAttributeType        *HeroAttributeType `boil:"BodyResistAttributeCodeHeroAttributeType" json:"BodyResistAttributeCodeHeroAttributeType" toml:"BodyResistAttributeCodeHeroAttributeType" yaml:"BodyResistAttributeCodeHeroAttributeType"`
	DodgeAttributeCodeHeroAttributeType             *HeroAttributeType `boil:"DodgeAttributeCodeHeroAttributeType" json:"DodgeAttributeCodeHeroAttributeType" toml:"DodgeAttributeCodeHeroAttributeType" yaml:"DodgeAttributeCodeHeroAttributeType"`
	EnvironmentResistAttributeCodeHeroAttributeType *HeroAttributeType `boil:"EnvironmentResistAttributeCodeHeroAttributeType" json:"EnvironmentResistAttributeCodeHeroAttributeType" toml:"EnvironmentResistAttributeCodeHeroAttributeType" yaml:"EnvironmentResistAttributeCodeHeroAttributeType"`
	InitiativeAttributeCodeHeroAttributeType        *HeroAttributeType `boil:"InitiativeAttributeCodeHeroAttributeType" json:"InitiativeAttributeCodeHeroAttributeType" toml:"InitiativeAttributeCodeHeroAttributeType" yaml:"InitiativeAttributeCodeHeroAttributeType"`
	MagicResistAttributeCodeHeroAttributeType       *HeroAttributeType `boil:"MagicResistAttributeCodeHeroAttributeType" json:"MagicResistAttributeCodeHeroAttributeType" toml:"MagicResistAttributeCodeHeroAttributeType" yaml:"MagicResistAttributeCodeHeroAttributeType"`
	MentalResistAttributeCodeHeroAttributeType      *HeroAttributeType `boil:"MentalResistAttributeCodeHeroAttributeType" json:"MentalResistAttributeCodeHeroAttributeType" toml:"MentalResistAttributeCodeHeroAttributeType" yaml:"MentalResistAttributeCodeHeroAttributeType"`
	MonsterDrops                                    MonsterDropSlice   `boil:"MonsterDrops" json:"MonsterDrops" toml:"MonsterDrops" yaml:"MonsterDrops"`
	MonsterSkills                                   MonsterSkillSlice  `boil:"MonsterSkills" json:"MonsterSkills" toml:"MonsterSkills" yaml:"MonsterSkills"`
}

// NewStruct creates a new relationship struct
func (*monsterR) NewStruct() *monsterR {
	return &monsterR{}
}

func (o *Monster) GetAccuracyAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetAccuracyAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetAccuracyAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.AccuracyAttributeCodeHeroAttributeType
}

func (o *Monster) GetBodyResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetBodyResistAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetBodyResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.BodyResistAttributeCodeHeroAttributeType
}

func (o *Monster) GetDodgeAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetDodgeAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetDodgeAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.DodgeAttributeCodeHeroAttributeType
}

func (o *Monster) GetEnvironmentResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetEnvironmentResistAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetEnvironmentResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.EnvironmentResistAttributeCodeHeroAttributeType
}

func (o *Monster) GetInitiativeAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetInitiativeAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetInitiativeAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.InitiativeAttributeCodeHeroAttributeType
}

func (o *Monster) GetMagicResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetMagicResistAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetMagicResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.MagicResistAttributeCodeHeroAttributeType
}

func (o *Monster) GetMentalResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if o == nil {
		return nil
	}

	return o.R.GetMentalResistAttributeCodeHeroAttributeType()
}

func (r *monsterR) GetMentalResistAttributeCodeHeroAttributeType() *HeroAttributeType {
	if r == nil {
		return nil
	}

	return r.MentalResistAttributeCodeHeroAttributeType
}

func (o *Monster) GetMonsterDrops() MonsterDropSlice {
	if o == nil {
		return nil
	}

	return o.R.GetMonsterDrops()
}

func (r *monsterR) GetMonsterDrops() MonsterDropSlice {
	if r == nil {
		return nil
	}

	return r.MonsterDrops
}

func (o *Monster) GetMonsterSkills() MonsterSkillSlice {
	if o == nil {
		return nil
	}

	return o.R.GetMonsterSkills()
}

func (r *monsterR) GetMonsterSkills() MonsterSkillSlice {
	if r == nil {
		return nil
	}

	return r.MonsterSkills
}

// monsterL is where Load methods for each relationship are stored.
type monsterL struct{}

var (
	monsterAllColumns            = []string{"id", "monster_code", "monster_name", "monster_level", "description", "max_hp", "hp_recovery", "max_mp", "mp_recovery", "base_str", "base_agi", "base_vit", "base_wlp", "base_int", "base_wis", "base_cha", "accuracy_attribute_code", "dodge_attribute_code", "initiative_attribute_code", "body_resist_attribute_code", "magic_resist_attribute_code", "mental_resist_attribute_code", "environment_resist_attribute_code", "damage_resistances", "passive_buffs", "drop_gold_min", "drop_gold_max", "drop_exp", "icon_url", "model_url", "is_active", "display_order", "created_at", "updated_at", "deleted_at"}
	monsterColumnsWithoutDefault = []string{"monster_code", "monster_name", "monster_level", "max_hp"}
	monsterColumnsWithDefault    = []string{"id", "description", "hp_recovery", "max_mp", "mp_recovery", "base_str", "base_agi", "base_vit", "base_wlp", "base_int", "base_wis", "base_cha", "accuracy_attribute_code", "dodge_attribute_code", "initiative_attribute_code", "body_resist_attribute_code", "magic_resist_attribute_code", "mental_resist_attribute_code", "environment_resist_attribute_code", "damage_resistances", "passive_buffs", "drop_gold_min", "drop_gold_max", "drop_exp", "icon_url", "model_url", "is_active", "display_order", "created_at", "updated_at", "deleted_at"}
	monsterPrimaryKeyColumns     = []string{"id"}
	monsterGeneratedColumns      = []string{}
)

type (
	// MonsterSlice is an alias for a slice of pointers to Monster.
	// This should almost always be used instead of []Monster.
	MonsterSlice []*Monster
	// MonsterHook is the signature for custom Monster hook methods
	MonsterHook func(context.Context, boil.ContextExecutor, *Monster) error

	monsterQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	monsterType                 = reflect.TypeOf(&Monster{})
	monsterMapping              = queries.MakeStructMapping(monsterType)
	monsterPrimaryKeyMapping, _ = queries.BindMapping(monsterType, monsterMapping, monsterPrimaryKeyColumns)
	monsterInsertCacheMut       sync.RWMutex
	monsterInsertCache          = make(map[string]insertCache)
	monsterUpdateCacheMut       sync.RWMutex
	monsterUpdateCache          = make(map[string]updateCache)
	monsterUpsertCacheMut       sync.RWMutex
	monsterUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var monsterAfterSelectMu sync.Mutex
var monsterAfterSelectHooks []MonsterHook

var monsterBeforeInsertMu sync.Mutex
var monsterBeforeInsertHooks []MonsterHook
var monsterAfterInsertMu sync.Mutex
var monsterAfterInsertHooks []MonsterHook

var monsterBeforeUpdateMu sync.Mutex
var monsterBeforeUpdateHooks []MonsterHook
var monsterAfterUpdateMu sync.Mutex
var monsterAfterUpdateHooks []MonsterHook

var monsterBeforeDeleteMu sync.Mutex
var monsterBeforeDeleteHooks []MonsterHook
var monsterAfterDeleteMu sync.Mutex
var monsterAfterDeleteHooks []MonsterHook

var monsterBeforeUpsertMu sync.Mutex
var monsterBeforeUpsertHooks []MonsterHook
var monsterAfterUpsertMu sync.Mutex
var monsterAfterUpsertHooks []MonsterHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Monster) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Monster) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Monster) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Monster) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Monster) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Monster) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Monster) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Monster) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Monster) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monsterAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMonsterHook registers your hook function for all future operations.
func AddMonsterHook(hookPoint boil.HookPoint, monsterHook MonsterHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		monsterAfterSelectMu.Lock()
		monsterAfterSelectHooks = append(monsterAfterSelectHooks, monsterHook)
		monsterAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		monsterBeforeInsertMu.Lock()
		monsterBeforeInsertHooks = append(monsterBeforeInsertHooks, monsterHook)
		monsterBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		monsterAfterInsertMu.Lock()
		monsterAfterInsertHooks = append(monsterAfterInsertHooks, monsterHook)
		monsterAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		monsterBeforeUpdateMu.Lock()
		monsterBeforeUpdateHooks = append(monsterBeforeUpdateHooks, monsterHook)
		monsterBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		monsterAfterUpdateMu.Lock()
		monsterAfterUpdateHooks = append(monsterAfterUpdateHooks, monsterHook)
		monsterAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		monsterBeforeDeleteMu.Lock()
		monsterBeforeDeleteHooks = append(monsterBeforeDeleteHooks, monsterHook)
		monsterBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		monsterAfterDeleteMu.Lock()
		monsterAfterDeleteHooks = append(monsterAfterDeleteHooks, monsterHook)
		monsterAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		monsterBeforeUpsertMu.Lock()
		monsterBeforeUpsertHooks = append(monsterBeforeUpsertHooks, monsterHook)
		monsterBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		monsterAfterUpsertMu.Lock()
		monsterAfterUpsertHooks = append(monsterAfterUpsertHooks, monsterHook)
		monsterAfterUpsertMu.Unlock()
	}
}

// OneG returns a single monster record from the query using the global executor.
func (q monsterQuery) OneG(ctx context.Context) (*Monster, error) {
	return q.One(ctx, boil.GetContextDB())
}

// OneGP returns a single monster record from the query using the global executor, and panics on error.
func (q monsterQuery) OneGP(ctx context.Context) *Monster {
	o, err := q.One(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single monster record from the query, and panics on error.
func (q monsterQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *Monster {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single monster record from the query.
func (q monsterQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Monster, error) {
	o := &Monster{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: failed to execute a one query for monsters")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Monster records from the query using the global executor.
func (q monsterQuery) AllG(ctx context.Context) (MonsterSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// AllGP returns all Monster records from the query using the global executor, and panics on error.
func (q monsterQuery) AllGP(ctx context.Context) MonsterSlice {
	o, err := q.All(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all Monster records from the query, and panics on error.
func (q monsterQuery) AllP(ctx context.Context, exec boil.ContextExecutor) MonsterSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all Monster records from the query.
func (q monsterQuery) All(ctx context.Context, exec boil.ContextExecutor) (MonsterSlice, error) {
	var o []*Monster

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "game_config: failed to assign all query results to Monster slice")
	}

	if len(monsterAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Monster records in the query using the global executor
func (q monsterQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// CountGP returns the count of all Monster records in the query using the global executor, and panics on error.
func (q monsterQuery) CountGP(ctx context.Context) int64 {
	c, err := q.Count(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all Monster records in the query, and panics on error.
func (q monsterQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all Monster records in the query.
func (q monsterQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to count monsters rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q monsterQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q monsterQuery) ExistsGP(ctx context.Context) bool {
	e, err := q.Exists(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q monsterQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q monsterQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "game_config: failed to check if monsters exists")
	}

	return count > 0, nil
}

// AccuracyAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) AccuracyAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.AccuracyAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// BodyResistAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) BodyResistAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.BodyResistAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// DodgeAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) DodgeAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.DodgeAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// EnvironmentResistAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) EnvironmentResistAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.EnvironmentResistAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// InitiativeAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) InitiativeAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.InitiativeAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// MagicResistAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) MagicResistAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.MagicResistAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// MentalResistAttributeCodeHeroAttributeType pointed to by the foreign key.
func (o *Monster) MentalResistAttributeCodeHeroAttributeType(mods ...qm.QueryMod) heroAttributeTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"attribute_code\" = ?", o.MentalResistAttributeCode),
	}

	queryMods = append(queryMods, mods...)

	return HeroAttributeTypes(queryMods...)
}

// MonsterDrops retrieves all the monster_drop's MonsterDrops with an executor.
func (o *Monster) MonsterDrops(mods ...qm.QueryMod) monsterDropQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"monster_drops\".\"monster_id\"=?", o.ID),
	)

	return MonsterDrops(queryMods...)
}

// MonsterSkills retrieves all the monster_skill's MonsterSkills with an executor.
func (o *Monster) MonsterSkills(mods ...qm.QueryMod) monsterSkillQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_config\".\"monster_skills\".\"monster_id\"=?", o.ID),
	)

	return MonsterSkills(queryMods...)
}

// LoadAccuracyAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadAccuracyAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.AccuracyAttributeCode) {
			args[object.AccuracyAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.AccuracyAttributeCode) {
				args[obj.AccuracyAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AccuracyAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.AccuracyAttributeCodeMonsters = append(foreign.R.AccuracyAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AccuracyAttributeCode, foreign.AttributeCode) {
				local.R.AccuracyAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.AccuracyAttributeCodeMonsters = append(foreign.R.AccuracyAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadBodyResistAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadBodyResistAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.BodyResistAttributeCode) {
			args[object.BodyResistAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.BodyResistAttributeCode) {
				args[obj.BodyResistAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BodyResistAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.BodyResistAttributeCodeMonsters = append(foreign.R.BodyResistAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BodyResistAttributeCode, foreign.AttributeCode) {
				local.R.BodyResistAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.BodyResistAttributeCodeMonsters = append(foreign.R.BodyResistAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadDodgeAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadDodgeAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.DodgeAttributeCode) {
			args[object.DodgeAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.DodgeAttributeCode) {
				args[obj.DodgeAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DodgeAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.DodgeAttributeCodeMonsters = append(foreign.R.DodgeAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DodgeAttributeCode, foreign.AttributeCode) {
				local.R.DodgeAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.DodgeAttributeCodeMonsters = append(foreign.R.DodgeAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadEnvironmentResistAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadEnvironmentResistAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.EnvironmentResistAttributeCode) {
			args[object.EnvironmentResistAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.EnvironmentResistAttributeCode) {
				args[obj.EnvironmentResistAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.EnvironmentResistAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.EnvironmentResistAttributeCodeMonsters = append(foreign.R.EnvironmentResistAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.EnvironmentResistAttributeCode, foreign.AttributeCode) {
				local.R.EnvironmentResistAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.EnvironmentResistAttributeCodeMonsters = append(foreign.R.EnvironmentResistAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadInitiativeAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadInitiativeAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.InitiativeAttributeCode) {
			args[object.InitiativeAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.InitiativeAttributeCode) {
				args[obj.InitiativeAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InitiativeAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.InitiativeAttributeCodeMonsters = append(foreign.R.InitiativeAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InitiativeAttributeCode, foreign.AttributeCode) {
				local.R.InitiativeAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.InitiativeAttributeCodeMonsters = append(foreign.R.InitiativeAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadMagicResistAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadMagicResistAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.MagicResistAttributeCode) {
			args[object.MagicResistAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.MagicResistAttributeCode) {
				args[obj.MagicResistAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MagicResistAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.MagicResistAttributeCodeMonsters = append(foreign.R.MagicResistAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MagicResistAttributeCode, foreign.AttributeCode) {
				local.R.MagicResistAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.MagicResistAttributeCodeMonsters = append(foreign.R.MagicResistAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadMentalResistAttributeCodeHeroAttributeType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monsterL) LoadMentalResistAttributeCodeHeroAttributeType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		if !queries.IsNil(object.MentalResistAttributeCode) {
			args[object.MentalResistAttributeCode] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}

			if !queries.IsNil(obj.MentalResistAttributeCode) {
				args[obj.MentalResistAttributeCode] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.hero_attribute_type`),
		qm.WhereIn(`game_config.hero_attribute_type.attribute_code in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.hero_attribute_type.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load HeroAttributeType")
	}

	var resultSlice []*HeroAttributeType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice HeroAttributeType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for hero_attribute_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hero_attribute_type")
	}

	if len(heroAttributeTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MentalResistAttributeCodeHeroAttributeType = foreign
		if foreign.R == nil {
			foreign.R = &heroAttributeTypeR{}
		}
		foreign.R.MentalResistAttributeCodeMonsters = append(foreign.R.MentalResistAttributeCodeMonsters, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MentalResistAttributeCode, foreign.AttributeCode) {
				local.R.MentalResistAttributeCodeHeroAttributeType = foreign
				if foreign.R == nil {
					foreign.R = &heroAttributeTypeR{}
				}
				foreign.R.MentalResistAttributeCodeMonsters = append(foreign.R.MentalResistAttributeCodeMonsters, local)
				break
			}
		}
	}

	return nil
}

// LoadMonsterDrops allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (monsterL) LoadMonsterDrops(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.monster_drops`),
		qm.WhereIn(`game_config.monster_drops.monster_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.monster_drops.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load monster_drops")
	}

	var resultSlice []*MonsterDrop
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice monster_drops")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on monster_drops")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for monster_drops")
	}

	if len(monsterDropAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MonsterDrops = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &monsterDropR{}
			}
			foreign.R.Monster = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MonsterID {
				local.R.MonsterDrops = append(local.R.MonsterDrops, foreign)
				if foreign.R == nil {
					foreign.R = &monsterDropR{}
				}
				foreign.R.Monster = local
				break
			}
		}
	}

	return nil
}

// LoadMonsterSkills allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (monsterL) LoadMonsterSkills(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonster interface{}, mods queries.Applicator) error {
	var slice []*Monster
	var object *Monster

	if singular {
		var ok bool
		object, ok = maybeMonster.(*Monster)
		if !ok {
			object = new(Monster)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonster))
			}
		}
	} else {
		s, ok := maybeMonster.(*[]*Monster)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonster)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonster))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &monsterR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monsterR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.monster_skills`),
		qm.WhereIn(`game_config.monster_skills.monster_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.monster_skills.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load monster_skills")
	}

	var resultSlice []*MonsterSkill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice monster_skills")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on monster_skills")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for monster_skills")
	}

	if len(monsterSkillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MonsterSkills = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &monsterSkillR{}
			}
			foreign.R.Monster = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MonsterID {
				local.R.MonsterSkills = append(local.R.MonsterSkills, foreign)
				if foreign.R == nil {
					foreign.R = &monsterSkillR{}
				}
				foreign.R.Monster = local
				break
			}
		}
	}

	return nil
}

// SetAccuracyAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to related.
// Adds o to related.R.AccuracyAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetAccuracyAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetAccuracyAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetAccuracyAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to related.
// Adds o to related.R.AccuracyAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetAccuracyAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetAccuracyAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetAccuracyAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to related.
// Adds o to related.R.AccuracyAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetAccuracyAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetAccuracyAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetAccuracyAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to related.
// Adds o to related.R.AccuracyAttributeCodeMonsters.
func (o *Monster) SetAccuracyAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"accuracy_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AccuracyAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			AccuracyAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.AccuracyAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			AccuracyAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.AccuracyAttributeCodeMonsters = append(related.R.AccuracyAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveAccuracyAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveAccuracyAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveAccuracyAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveAccuracyAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveAccuracyAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveAccuracyAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveAccuracyAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveAccuracyAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveAccuracyAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveAccuracyAttributeCodeHeroAttributeType relationship.
// Sets o.R.AccuracyAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveAccuracyAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.AccuracyAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("accuracy_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.AccuracyAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AccuracyAttributeCodeMonsters {
		if queries.Equal(o.AccuracyAttributeCode, ri.AccuracyAttributeCode) {
			continue
		}

		ln := len(related.R.AccuracyAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.AccuracyAttributeCodeMonsters[i] = related.R.AccuracyAttributeCodeMonsters[ln-1]
		}
		related.R.AccuracyAttributeCodeMonsters = related.R.AccuracyAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// SetBodyResistAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.BodyResistAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetBodyResistAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetBodyResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetBodyResistAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.BodyResistAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetBodyResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetBodyResistAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetBodyResistAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.BodyResistAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetBodyResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetBodyResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetBodyResistAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.BodyResistAttributeCodeMonsters.
func (o *Monster) SetBodyResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"body_resist_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BodyResistAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			BodyResistAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.BodyResistAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			BodyResistAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.BodyResistAttributeCodeMonsters = append(related.R.BodyResistAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveBodyResistAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveBodyResistAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveBodyResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveBodyResistAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveBodyResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveBodyResistAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveBodyResistAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveBodyResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveBodyResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveBodyResistAttributeCodeHeroAttributeType relationship.
// Sets o.R.BodyResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveBodyResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.BodyResistAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("body_resist_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BodyResistAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BodyResistAttributeCodeMonsters {
		if queries.Equal(o.BodyResistAttributeCode, ri.BodyResistAttributeCode) {
			continue
		}

		ln := len(related.R.BodyResistAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.BodyResistAttributeCodeMonsters[i] = related.R.BodyResistAttributeCodeMonsters[ln-1]
		}
		related.R.BodyResistAttributeCodeMonsters = related.R.BodyResistAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// SetDodgeAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.DodgeAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetDodgeAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetDodgeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetDodgeAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.DodgeAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetDodgeAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetDodgeAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetDodgeAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.DodgeAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetDodgeAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetDodgeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetDodgeAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.DodgeAttributeCodeMonsters.
func (o *Monster) SetDodgeAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"dodge_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DodgeAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			DodgeAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.DodgeAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			DodgeAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.DodgeAttributeCodeMonsters = append(related.R.DodgeAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveDodgeAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveDodgeAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveDodgeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveDodgeAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveDodgeAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveDodgeAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveDodgeAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveDodgeAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveDodgeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveDodgeAttributeCodeHeroAttributeType relationship.
// Sets o.R.DodgeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveDodgeAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.DodgeAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("dodge_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DodgeAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DodgeAttributeCodeMonsters {
		if queries.Equal(o.DodgeAttributeCode, ri.DodgeAttributeCode) {
			continue
		}

		ln := len(related.R.DodgeAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.DodgeAttributeCodeMonsters[i] = related.R.DodgeAttributeCodeMonsters[ln-1]
		}
		related.R.DodgeAttributeCodeMonsters = related.R.DodgeAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// SetEnvironmentResistAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.EnvironmentResistAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetEnvironmentResistAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetEnvironmentResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetEnvironmentResistAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.EnvironmentResistAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetEnvironmentResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetEnvironmentResistAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetEnvironmentResistAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.EnvironmentResistAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetEnvironmentResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetEnvironmentResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetEnvironmentResistAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.EnvironmentResistAttributeCodeMonsters.
func (o *Monster) SetEnvironmentResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"environment_resist_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.EnvironmentResistAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			EnvironmentResistAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.EnvironmentResistAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			EnvironmentResistAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.EnvironmentResistAttributeCodeMonsters = append(related.R.EnvironmentResistAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveEnvironmentResistAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveEnvironmentResistAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveEnvironmentResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveEnvironmentResistAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveEnvironmentResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveEnvironmentResistAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveEnvironmentResistAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveEnvironmentResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveEnvironmentResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveEnvironmentResistAttributeCodeHeroAttributeType relationship.
// Sets o.R.EnvironmentResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveEnvironmentResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.EnvironmentResistAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("environment_resist_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.EnvironmentResistAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.EnvironmentResistAttributeCodeMonsters {
		if queries.Equal(o.EnvironmentResistAttributeCode, ri.EnvironmentResistAttributeCode) {
			continue
		}

		ln := len(related.R.EnvironmentResistAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.EnvironmentResistAttributeCodeMonsters[i] = related.R.EnvironmentResistAttributeCodeMonsters[ln-1]
		}
		related.R.EnvironmentResistAttributeCodeMonsters = related.R.EnvironmentResistAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// SetInitiativeAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.InitiativeAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetInitiativeAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetInitiativeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetInitiativeAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.InitiativeAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetInitiativeAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetInitiativeAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetInitiativeAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.InitiativeAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetInitiativeAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetInitiativeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetInitiativeAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to related.
// Adds o to related.R.InitiativeAttributeCodeMonsters.
func (o *Monster) SetInitiativeAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"initiative_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InitiativeAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			InitiativeAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.InitiativeAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			InitiativeAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.InitiativeAttributeCodeMonsters = append(related.R.InitiativeAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveInitiativeAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveInitiativeAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveInitiativeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveInitiativeAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveInitiativeAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveInitiativeAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveInitiativeAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveInitiativeAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveInitiativeAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveInitiativeAttributeCodeHeroAttributeType relationship.
// Sets o.R.InitiativeAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveInitiativeAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.InitiativeAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("initiative_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InitiativeAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.InitiativeAttributeCodeMonsters {
		if queries.Equal(o.InitiativeAttributeCode, ri.InitiativeAttributeCode) {
			continue
		}

		ln := len(related.R.InitiativeAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.InitiativeAttributeCodeMonsters[i] = related.R.InitiativeAttributeCodeMonsters[ln-1]
		}
		related.R.InitiativeAttributeCodeMonsters = related.R.InitiativeAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// SetMagicResistAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MagicResistAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetMagicResistAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetMagicResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetMagicResistAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MagicResistAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetMagicResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetMagicResistAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetMagicResistAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MagicResistAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetMagicResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetMagicResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetMagicResistAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MagicResistAttributeCodeMonsters.
func (o *Monster) SetMagicResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"magic_resist_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MagicResistAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			MagicResistAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.MagicResistAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			MagicResistAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.MagicResistAttributeCodeMonsters = append(related.R.MagicResistAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveMagicResistAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveMagicResistAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveMagicResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveMagicResistAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveMagicResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveMagicResistAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveMagicResistAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveMagicResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveMagicResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveMagicResistAttributeCodeHeroAttributeType relationship.
// Sets o.R.MagicResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveMagicResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.MagicResistAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("magic_resist_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MagicResistAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MagicResistAttributeCodeMonsters {
		if queries.Equal(o.MagicResistAttributeCode, ri.MagicResistAttributeCode) {
			continue
		}

		ln := len(related.R.MagicResistAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.MagicResistAttributeCodeMonsters[i] = related.R.MagicResistAttributeCodeMonsters[ln-1]
		}
		related.R.MagicResistAttributeCodeMonsters = related.R.MagicResistAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// SetMentalResistAttributeCodeHeroAttributeTypeG of the monster to the related item.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MentalResistAttributeCodeMonsters.
// Uses the global database handle.
func (o *Monster) SetMentalResistAttributeCodeHeroAttributeTypeG(ctx context.Context, insert bool, related *HeroAttributeType) error {
	return o.SetMentalResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related)
}

// SetMentalResistAttributeCodeHeroAttributeTypeP of the monster to the related item.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MentalResistAttributeCodeMonsters.
// Panics on error.
func (o *Monster) SetMentalResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) {
	if err := o.SetMentalResistAttributeCodeHeroAttributeType(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetMentalResistAttributeCodeHeroAttributeTypeGP of the monster to the related item.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MentalResistAttributeCodeMonsters.
// Uses the global database handle and panics on error.
func (o *Monster) SetMentalResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, insert bool, related *HeroAttributeType) {
	if err := o.SetMentalResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetMentalResistAttributeCodeHeroAttributeType of the monster to the related item.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to related.
// Adds o to related.R.MentalResistAttributeCodeMonsters.
func (o *Monster) SetMentalResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *HeroAttributeType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"mental_resist_attribute_code"}),
		strmangle.WhereClause("\"", "\"", 2, monsterPrimaryKeyColumns),
	)
	values := []interface{}{related.AttributeCode, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MentalResistAttributeCode, related.AttributeCode)
	if o.R == nil {
		o.R = &monsterR{
			MentalResistAttributeCodeHeroAttributeType: related,
		}
	} else {
		o.R.MentalResistAttributeCodeHeroAttributeType = related
	}

	if related.R == nil {
		related.R = &heroAttributeTypeR{
			MentalResistAttributeCodeMonsters: MonsterSlice{o},
		}
	} else {
		related.R.MentalResistAttributeCodeMonsters = append(related.R.MentalResistAttributeCodeMonsters, o)
	}

	return nil
}

// RemoveMentalResistAttributeCodeHeroAttributeTypeG relationship.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Monster) RemoveMentalResistAttributeCodeHeroAttributeTypeG(ctx context.Context, related *HeroAttributeType) error {
	return o.RemoveMentalResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related)
}

// RemoveMentalResistAttributeCodeHeroAttributeTypeP relationship.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Panics on error.
func (o *Monster) RemoveMentalResistAttributeCodeHeroAttributeTypeP(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) {
	if err := o.RemoveMentalResistAttributeCodeHeroAttributeType(ctx, exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveMentalResistAttributeCodeHeroAttributeTypeGP relationship.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle and panics on error.
func (o *Monster) RemoveMentalResistAttributeCodeHeroAttributeTypeGP(ctx context.Context, related *HeroAttributeType) {
	if err := o.RemoveMentalResistAttributeCodeHeroAttributeType(ctx, boil.GetContextDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveMentalResistAttributeCodeHeroAttributeType relationship.
// Sets o.R.MentalResistAttributeCodeHeroAttributeType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Monster) RemoveMentalResistAttributeCodeHeroAttributeType(ctx context.Context, exec boil.ContextExecutor, related *HeroAttributeType) error {
	var err error

	queries.SetScanner(&o.MentalResistAttributeCode, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("mental_resist_attribute_code")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MentalResistAttributeCodeHeroAttributeType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MentalResistAttributeCodeMonsters {
		if queries.Equal(o.MentalResistAttributeCode, ri.MentalResistAttributeCode) {
			continue
		}

		ln := len(related.R.MentalResistAttributeCodeMonsters)
		if ln > 1 && i < ln-1 {
			related.R.MentalResistAttributeCodeMonsters[i] = related.R.MentalResistAttributeCodeMonsters[ln-1]
		}
		related.R.MentalResistAttributeCodeMonsters = related.R.MentalResistAttributeCodeMonsters[:ln-1]
		break
	}
	return nil
}

// AddMonsterDropsG adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterDrops.
// Sets related.R.Monster appropriately.
// Uses the global database handle.
func (o *Monster) AddMonsterDropsG(ctx context.Context, insert bool, related ...*MonsterDrop) error {
	return o.AddMonsterDrops(ctx, boil.GetContextDB(), insert, related...)
}

// AddMonsterDropsP adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterDrops.
// Sets related.R.Monster appropriately.
// Panics on error.
func (o *Monster) AddMonsterDropsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MonsterDrop) {
	if err := o.AddMonsterDrops(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddMonsterDropsGP adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterDrops.
// Sets related.R.Monster appropriately.
// Uses the global database handle and panics on error.
func (o *Monster) AddMonsterDropsGP(ctx context.Context, insert bool, related ...*MonsterDrop) {
	if err := o.AddMonsterDrops(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddMonsterDrops adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterDrops.
// Sets related.R.Monster appropriately.
func (o *Monster) AddMonsterDrops(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MonsterDrop) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MonsterID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"monster_drops\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"monster_id"}),
				strmangle.WhereClause("\"", "\"", 2, monsterDropPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MonsterID = o.ID
		}
	}

	if o.R == nil {
		o.R = &monsterR{
			MonsterDrops: related,
		}
	} else {
		o.R.MonsterDrops = append(o.R.MonsterDrops, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &monsterDropR{
				Monster: o,
			}
		} else {
			rel.R.Monster = o
		}
	}
	return nil
}

// AddMonsterSkillsG adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterSkills.
// Sets related.R.Monster appropriately.
// Uses the global database handle.
func (o *Monster) AddMonsterSkillsG(ctx context.Context, insert bool, related ...*MonsterSkill) error {
	return o.AddMonsterSkills(ctx, boil.GetContextDB(), insert, related...)
}

// AddMonsterSkillsP adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterSkills.
// Sets related.R.Monster appropriately.
// Panics on error.
func (o *Monster) AddMonsterSkillsP(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MonsterSkill) {
	if err := o.AddMonsterSkills(ctx, exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddMonsterSkillsGP adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterSkills.
// Sets related.R.Monster appropriately.
// Uses the global database handle and panics on error.
func (o *Monster) AddMonsterSkillsGP(ctx context.Context, insert bool, related ...*MonsterSkill) {
	if err := o.AddMonsterSkills(ctx, boil.GetContextDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddMonsterSkills adds the given related objects to the existing relationships
// of the monster, optionally inserting them as new records.
// Appends related to o.R.MonsterSkills.
// Sets related.R.Monster appropriately.
func (o *Monster) AddMonsterSkills(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MonsterSkill) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MonsterID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_config\".\"monster_skills\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"monster_id"}),
				strmangle.WhereClause("\"", "\"", 2, monsterSkillPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MonsterID = o.ID
		}
	}

	if o.R == nil {
		o.R = &monsterR{
			MonsterSkills: related,
		}
	} else {
		o.R.MonsterSkills = append(o.R.MonsterSkills, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &monsterSkillR{
				Monster: o,
			}
		} else {
			rel.R.Monster = o
		}
	}
	return nil
}

// Monsters retrieves all the records using an executor.
func Monsters(mods ...qm.QueryMod) monsterQuery {
	mods = append(mods, qm.From("\"game_config\".\"monsters\""), qmhelper.WhereIsNull("\"game_config\".\"monsters\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_config\".\"monsters\".*"})
	}

	return monsterQuery{q}
}

// FindMonsterG retrieves a single record by ID.
func FindMonsterG(ctx context.Context, iD string, selectCols ...string) (*Monster, error) {
	return FindMonster(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindMonsterP retrieves a single record by ID with an executor, and panics on error.
func FindMonsterP(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) *Monster {
	retobj, err := FindMonster(ctx, exec, iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindMonsterGP retrieves a single record by ID, and panics on error.
func FindMonsterGP(ctx context.Context, iD string, selectCols ...string) *Monster {
	retobj, err := FindMonster(ctx, boil.GetContextDB(), iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindMonster retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMonster(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Monster, error) {
	monsterObj := &Monster{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_config\".\"monsters\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, monsterObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: unable to select from monsters")
	}

	if err = monsterObj.doAfterSelectHooks(ctx, exec); err != nil {
		return monsterObj, err
	}

	return monsterObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Monster) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *Monster) InsertP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) {
	if err := o.Insert(ctx, exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *Monster) InsertGP(ctx context.Context, columns boil.Columns) {
	if err := o.Insert(ctx, boil.GetContextDB(), columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Monster) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("game_config: no monsters provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(monsterColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	monsterInsertCacheMut.RLock()
	cache, cached := monsterInsertCache[key]
	monsterInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			monsterAllColumns,
			monsterColumnsWithDefault,
			monsterColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(monsterType, monsterMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(monsterType, monsterMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_config\".\"monsters\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_config\".\"monsters\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "game_config: unable to insert into monsters")
	}

	if !cached {
		monsterInsertCacheMut.Lock()
		monsterInsertCache[key] = cache
		monsterInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Monster record using the global executor.
// See Update for more documentation.
func (o *Monster) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// UpdateP uses an executor to update the Monster, and panics on error.
// See Update for more documentation.
func (o *Monster) UpdateP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateGP a single Monster record using the global executor. Panics on error.
// See Update for more documentation.
func (o *Monster) UpdateGP(ctx context.Context, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, boil.GetContextDB(), columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Update uses an executor to update the Monster.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Monster) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	monsterUpdateCacheMut.RLock()
	cache, cached := monsterUpdateCache[key]
	monsterUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			monsterAllColumns,
			monsterPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("game_config: unable to update monsters, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, monsterPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(monsterType, monsterMapping, append(wl, monsterPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update monsters row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by update for monsters")
	}

	if !cached {
		monsterUpdateCacheMut.Lock()
		monsterUpdateCache[key] = cache
		monsterUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q monsterQuery) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllG updates all rows with the specified column values.
func (q monsterQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (q monsterQuery) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values.
func (q monsterQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all for monsters")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected for monsters")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o MonsterSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o MonsterSlice) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o MonsterSlice) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MonsterSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("game_config: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monsterPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_config\".\"monsters\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, monsterPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all in monster slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected all in update all monster")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Monster) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *Monster) UpsertGP(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *Monster) UpsertP(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, exec, updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Monster) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("game_config: no monsters provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(monsterColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	monsterUpsertCacheMut.RLock()
	cache, cached := monsterUpsertCache[key]
	monsterUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			monsterAllColumns,
			monsterColumnsWithDefault,
			monsterColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			monsterAllColumns,
			monsterPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("game_config: unable to upsert monsters, could not build update column list")
		}

		ret := strmangle.SetComplement(monsterAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(monsterPrimaryKeyColumns) == 0 {
				return errors.New("game_config: unable to upsert monsters, could not build conflict column list")
			}

			conflict = make([]string, len(monsterPrimaryKeyColumns))
			copy(conflict, monsterPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_config\".\"monsters\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(monsterType, monsterMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(monsterType, monsterMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "game_config: unable to upsert monsters")
	}

	if !cached {
		monsterUpsertCacheMut.Lock()
		monsterUpsertCache[key] = cache
		monsterUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Monster record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Monster) DeleteG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteP deletes a single Monster record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Monster) DeleteP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteGP deletes a single Monster record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Monster) DeleteGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Delete deletes a single Monster record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Monster) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("game_config: no Monster provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), monsterPrimaryKeyMapping)
		sql = "DELETE FROM \"game_config\".\"monsters\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"monsters\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(monsterType, monsterMapping, append(wl, monsterPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete from monsters")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by delete for monsters")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q monsterQuery) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows, and panics on error.
func (q monsterQuery) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows, and panics on error.
func (q monsterQuery) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all matching rows.
func (q monsterQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("game_config: no monsterQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from monsters")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for monsters")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o MonsterSlice) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o MonsterSlice) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o MonsterSlice) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MonsterSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(monsterBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monsterPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"game_config\".\"monsters\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, monsterPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monsterPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"monsters\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, monsterPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from monster slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for monsters")
	}

	if len(monsterAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Monster) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: no Monster provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *Monster) ReloadP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.Reload(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadGP refetches the object from the database and panics on error.
func (o *Monster) ReloadGP(ctx context.Context) {
	if err := o.Reload(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Monster) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMonster(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MonsterSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: empty MonsterSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *MonsterSlice) ReloadAllP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.ReloadAll(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *MonsterSlice) ReloadAllGP(ctx context.Context) {
	if err := o.ReloadAll(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MonsterSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MonsterSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monsterPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_config\".\"monsters\".* FROM \"game_config\".\"monsters\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, monsterPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "game_config: unable to reload all in MonsterSlice")
	}

	*o = slice

	return nil
}

// MonsterExistsG checks if the Monster row exists.
func MonsterExistsG(ctx context.Context, iD string) (bool, error) {
	return MonsterExists(ctx, boil.GetContextDB(), iD)
}

// MonsterExistsP checks if the Monster row exists. Panics on error.
func MonsterExistsP(ctx context.Context, exec boil.ContextExecutor, iD string) bool {
	e, err := MonsterExists(ctx, exec, iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// MonsterExistsGP checks if the Monster row exists. Panics on error.
func MonsterExistsGP(ctx context.Context, iD string) bool {
	e, err := MonsterExists(ctx, boil.GetContextDB(), iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// MonsterExists checks if the Monster row exists.
func MonsterExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_config\".\"monsters\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "game_config: unable to check if monsters exists")
	}

	return exists, nil
}

// Exists checks if the Monster row exists.
func (o *Monster) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return MonsterExists(ctx, exec, o.ID)
}
