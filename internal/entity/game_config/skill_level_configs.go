// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package game_config

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// SkillLevelConfig is an object representing the database table.
type SkillLevelConfig struct {
	ID                string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	SkillID           string            `boil:"skill_id" json:"skill_id" toml:"skill_id" yaml:"skill_id"`
	LevelNumber       int               `boil:"level_number" json:"level_number" toml:"level_number" yaml:"level_number"`
	DamageMultiplier  types.NullDecimal `boil:"damage_multiplier" json:"damage_multiplier,omitempty" toml:"damage_multiplier" yaml:"damage_multiplier,omitempty"`
	HealingMultiplier types.NullDecimal `boil:"healing_multiplier" json:"healing_multiplier,omitempty" toml:"healing_multiplier" yaml:"healing_multiplier,omitempty"`
	DurationModifier  null.Int          `boil:"duration_modifier" json:"duration_modifier,omitempty" toml:"duration_modifier" yaml:"duration_modifier,omitempty"`
	RangeModifier     null.Int          `boil:"range_modifier" json:"range_modifier,omitempty" toml:"range_modifier" yaml:"range_modifier,omitempty"`
	CooldownModifier  null.Int          `boil:"cooldown_modifier" json:"cooldown_modifier,omitempty" toml:"cooldown_modifier" yaml:"cooldown_modifier,omitempty"`
	ManaCostModifier  null.Int          `boil:"mana_cost_modifier" json:"mana_cost_modifier,omitempty" toml:"mana_cost_modifier" yaml:"mana_cost_modifier,omitempty"`
	EffectModifiers   null.JSON         `boil:"effect_modifiers" json:"effect_modifiers,omitempty" toml:"effect_modifiers" yaml:"effect_modifiers,omitempty"`
	UpgradeCostXP     null.Int          `boil:"upgrade_cost_xp" json:"upgrade_cost_xp,omitempty" toml:"upgrade_cost_xp" yaml:"upgrade_cost_xp,omitempty"`
	UpgradeCostGold   null.Int          `boil:"upgrade_cost_gold" json:"upgrade_cost_gold,omitempty" toml:"upgrade_cost_gold" yaml:"upgrade_cost_gold,omitempty"`
	UpgradeMaterials  null.JSON         `boil:"upgrade_materials" json:"upgrade_materials,omitempty" toml:"upgrade_materials" yaml:"upgrade_materials,omitempty"`
	CreatedAt         null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt         null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt         null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *skillLevelConfigR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L skillLevelConfigL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SkillLevelConfigColumns = struct {
	ID                string
	SkillID           string
	LevelNumber       string
	DamageMultiplier  string
	HealingMultiplier string
	DurationModifier  string
	RangeModifier     string
	CooldownModifier  string
	ManaCostModifier  string
	EffectModifiers   string
	UpgradeCostXP     string
	UpgradeCostGold   string
	UpgradeMaterials  string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
}{
	ID:                "id",
	SkillID:           "skill_id",
	LevelNumber:       "level_number",
	DamageMultiplier:  "damage_multiplier",
	HealingMultiplier: "healing_multiplier",
	DurationModifier:  "duration_modifier",
	RangeModifier:     "range_modifier",
	CooldownModifier:  "cooldown_modifier",
	ManaCostModifier:  "mana_cost_modifier",
	EffectModifiers:   "effect_modifiers",
	UpgradeCostXP:     "upgrade_cost_xp",
	UpgradeCostGold:   "upgrade_cost_gold",
	UpgradeMaterials:  "upgrade_materials",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
	DeletedAt:         "deleted_at",
}

var SkillLevelConfigTableColumns = struct {
	ID                string
	SkillID           string
	LevelNumber       string
	DamageMultiplier  string
	HealingMultiplier string
	DurationModifier  string
	RangeModifier     string
	CooldownModifier  string
	ManaCostModifier  string
	EffectModifiers   string
	UpgradeCostXP     string
	UpgradeCostGold   string
	UpgradeMaterials  string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
}{
	ID:                "skill_level_configs.id",
	SkillID:           "skill_level_configs.skill_id",
	LevelNumber:       "skill_level_configs.level_number",
	DamageMultiplier:  "skill_level_configs.damage_multiplier",
	HealingMultiplier: "skill_level_configs.healing_multiplier",
	DurationModifier:  "skill_level_configs.duration_modifier",
	RangeModifier:     "skill_level_configs.range_modifier",
	CooldownModifier:  "skill_level_configs.cooldown_modifier",
	ManaCostModifier:  "skill_level_configs.mana_cost_modifier",
	EffectModifiers:   "skill_level_configs.effect_modifiers",
	UpgradeCostXP:     "skill_level_configs.upgrade_cost_xp",
	UpgradeCostGold:   "skill_level_configs.upgrade_cost_gold",
	UpgradeMaterials:  "skill_level_configs.upgrade_materials",
	CreatedAt:         "skill_level_configs.created_at",
	UpdatedAt:         "skill_level_configs.updated_at",
	DeletedAt:         "skill_level_configs.deleted_at",
}

// Generated where

var SkillLevelConfigWhere = struct {
	ID                whereHelperstring
	SkillID           whereHelperstring
	LevelNumber       whereHelperint
	DamageMultiplier  whereHelpertypes_NullDecimal
	HealingMultiplier whereHelpertypes_NullDecimal
	DurationModifier  whereHelpernull_Int
	RangeModifier     whereHelpernull_Int
	CooldownModifier  whereHelpernull_Int
	ManaCostModifier  whereHelpernull_Int
	EffectModifiers   whereHelpernull_JSON
	UpgradeCostXP     whereHelpernull_Int
	UpgradeCostGold   whereHelpernull_Int
	UpgradeMaterials  whereHelpernull_JSON
	CreatedAt         whereHelpernull_Time
	UpdatedAt         whereHelpernull_Time
	DeletedAt         whereHelpernull_Time
}{
	ID:                whereHelperstring{field: "\"game_config\".\"skill_level_configs\".\"id\""},
	SkillID:           whereHelperstring{field: "\"game_config\".\"skill_level_configs\".\"skill_id\""},
	LevelNumber:       whereHelperint{field: "\"game_config\".\"skill_level_configs\".\"level_number\""},
	DamageMultiplier:  whereHelpertypes_NullDecimal{field: "\"game_config\".\"skill_level_configs\".\"damage_multiplier\""},
	HealingMultiplier: whereHelpertypes_NullDecimal{field: "\"game_config\".\"skill_level_configs\".\"healing_multiplier\""},
	DurationModifier:  whereHelpernull_Int{field: "\"game_config\".\"skill_level_configs\".\"duration_modifier\""},
	RangeModifier:     whereHelpernull_Int{field: "\"game_config\".\"skill_level_configs\".\"range_modifier\""},
	CooldownModifier:  whereHelpernull_Int{field: "\"game_config\".\"skill_level_configs\".\"cooldown_modifier\""},
	ManaCostModifier:  whereHelpernull_Int{field: "\"game_config\".\"skill_level_configs\".\"mana_cost_modifier\""},
	EffectModifiers:   whereHelpernull_JSON{field: "\"game_config\".\"skill_level_configs\".\"effect_modifiers\""},
	UpgradeCostXP:     whereHelpernull_Int{field: "\"game_config\".\"skill_level_configs\".\"upgrade_cost_xp\""},
	UpgradeCostGold:   whereHelpernull_Int{field: "\"game_config\".\"skill_level_configs\".\"upgrade_cost_gold\""},
	UpgradeMaterials:  whereHelpernull_JSON{field: "\"game_config\".\"skill_level_configs\".\"upgrade_materials\""},
	CreatedAt:         whereHelpernull_Time{field: "\"game_config\".\"skill_level_configs\".\"created_at\""},
	UpdatedAt:         whereHelpernull_Time{field: "\"game_config\".\"skill_level_configs\".\"updated_at\""},
	DeletedAt:         whereHelpernull_Time{field: "\"game_config\".\"skill_level_configs\".\"deleted_at\""},
}

// SkillLevelConfigRels is where relationship names are stored.
var SkillLevelConfigRels = struct {
	Skill string
}{
	Skill: "Skill",
}

// skillLevelConfigR is where relationships are stored.
type skillLevelConfigR struct {
	Skill *Skill `boil:"Skill" json:"Skill" toml:"Skill" yaml:"Skill"`
}

// NewStruct creates a new relationship struct
func (*skillLevelConfigR) NewStruct() *skillLevelConfigR {
	return &skillLevelConfigR{}
}

func (o *SkillLevelConfig) GetSkill() *Skill {
	if o == nil {
		return nil
	}

	return o.R.GetSkill()
}

func (r *skillLevelConfigR) GetSkill() *Skill {
	if r == nil {
		return nil
	}

	return r.Skill
}

// skillLevelConfigL is where Load methods for each relationship are stored.
type skillLevelConfigL struct{}

var (
	skillLevelConfigAllColumns            = []string{"id", "skill_id", "level_number", "damage_multiplier", "healing_multiplier", "duration_modifier", "range_modifier", "cooldown_modifier", "mana_cost_modifier", "effect_modifiers", "upgrade_cost_xp", "upgrade_cost_gold", "upgrade_materials", "created_at", "updated_at", "deleted_at"}
	skillLevelConfigColumnsWithoutDefault = []string{"skill_id", "level_number"}
	skillLevelConfigColumnsWithDefault    = []string{"id", "damage_multiplier", "healing_multiplier", "duration_modifier", "range_modifier", "cooldown_modifier", "mana_cost_modifier", "effect_modifiers", "upgrade_cost_xp", "upgrade_cost_gold", "upgrade_materials", "created_at", "updated_at", "deleted_at"}
	skillLevelConfigPrimaryKeyColumns     = []string{"id"}
	skillLevelConfigGeneratedColumns      = []string{}
)

type (
	// SkillLevelConfigSlice is an alias for a slice of pointers to SkillLevelConfig.
	// This should almost always be used instead of []SkillLevelConfig.
	SkillLevelConfigSlice []*SkillLevelConfig
	// SkillLevelConfigHook is the signature for custom SkillLevelConfig hook methods
	SkillLevelConfigHook func(context.Context, boil.ContextExecutor, *SkillLevelConfig) error

	skillLevelConfigQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	skillLevelConfigType                 = reflect.TypeOf(&SkillLevelConfig{})
	skillLevelConfigMapping              = queries.MakeStructMapping(skillLevelConfigType)
	skillLevelConfigPrimaryKeyMapping, _ = queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, skillLevelConfigPrimaryKeyColumns)
	skillLevelConfigInsertCacheMut       sync.RWMutex
	skillLevelConfigInsertCache          = make(map[string]insertCache)
	skillLevelConfigUpdateCacheMut       sync.RWMutex
	skillLevelConfigUpdateCache          = make(map[string]updateCache)
	skillLevelConfigUpsertCacheMut       sync.RWMutex
	skillLevelConfigUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var skillLevelConfigAfterSelectMu sync.Mutex
var skillLevelConfigAfterSelectHooks []SkillLevelConfigHook

var skillLevelConfigBeforeInsertMu sync.Mutex
var skillLevelConfigBeforeInsertHooks []SkillLevelConfigHook
var skillLevelConfigAfterInsertMu sync.Mutex
var skillLevelConfigAfterInsertHooks []SkillLevelConfigHook

var skillLevelConfigBeforeUpdateMu sync.Mutex
var skillLevelConfigBeforeUpdateHooks []SkillLevelConfigHook
var skillLevelConfigAfterUpdateMu sync.Mutex
var skillLevelConfigAfterUpdateHooks []SkillLevelConfigHook

var skillLevelConfigBeforeDeleteMu sync.Mutex
var skillLevelConfigBeforeDeleteHooks []SkillLevelConfigHook
var skillLevelConfigAfterDeleteMu sync.Mutex
var skillLevelConfigAfterDeleteHooks []SkillLevelConfigHook

var skillLevelConfigBeforeUpsertMu sync.Mutex
var skillLevelConfigBeforeUpsertHooks []SkillLevelConfigHook
var skillLevelConfigAfterUpsertMu sync.Mutex
var skillLevelConfigAfterUpsertHooks []SkillLevelConfigHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SkillLevelConfig) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SkillLevelConfig) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SkillLevelConfig) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SkillLevelConfig) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SkillLevelConfig) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SkillLevelConfig) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SkillLevelConfig) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SkillLevelConfig) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SkillLevelConfig) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range skillLevelConfigAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSkillLevelConfigHook registers your hook function for all future operations.
func AddSkillLevelConfigHook(hookPoint boil.HookPoint, skillLevelConfigHook SkillLevelConfigHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		skillLevelConfigAfterSelectMu.Lock()
		skillLevelConfigAfterSelectHooks = append(skillLevelConfigAfterSelectHooks, skillLevelConfigHook)
		skillLevelConfigAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		skillLevelConfigBeforeInsertMu.Lock()
		skillLevelConfigBeforeInsertHooks = append(skillLevelConfigBeforeInsertHooks, skillLevelConfigHook)
		skillLevelConfigBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		skillLevelConfigAfterInsertMu.Lock()
		skillLevelConfigAfterInsertHooks = append(skillLevelConfigAfterInsertHooks, skillLevelConfigHook)
		skillLevelConfigAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		skillLevelConfigBeforeUpdateMu.Lock()
		skillLevelConfigBeforeUpdateHooks = append(skillLevelConfigBeforeUpdateHooks, skillLevelConfigHook)
		skillLevelConfigBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		skillLevelConfigAfterUpdateMu.Lock()
		skillLevelConfigAfterUpdateHooks = append(skillLevelConfigAfterUpdateHooks, skillLevelConfigHook)
		skillLevelConfigAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		skillLevelConfigBeforeDeleteMu.Lock()
		skillLevelConfigBeforeDeleteHooks = append(skillLevelConfigBeforeDeleteHooks, skillLevelConfigHook)
		skillLevelConfigBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		skillLevelConfigAfterDeleteMu.Lock()
		skillLevelConfigAfterDeleteHooks = append(skillLevelConfigAfterDeleteHooks, skillLevelConfigHook)
		skillLevelConfigAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		skillLevelConfigBeforeUpsertMu.Lock()
		skillLevelConfigBeforeUpsertHooks = append(skillLevelConfigBeforeUpsertHooks, skillLevelConfigHook)
		skillLevelConfigBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		skillLevelConfigAfterUpsertMu.Lock()
		skillLevelConfigAfterUpsertHooks = append(skillLevelConfigAfterUpsertHooks, skillLevelConfigHook)
		skillLevelConfigAfterUpsertMu.Unlock()
	}
}

// OneG returns a single skillLevelConfig record from the query using the global executor.
func (q skillLevelConfigQuery) OneG(ctx context.Context) (*SkillLevelConfig, error) {
	return q.One(ctx, boil.GetContextDB())
}

// OneGP returns a single skillLevelConfig record from the query using the global executor, and panics on error.
func (q skillLevelConfigQuery) OneGP(ctx context.Context) *SkillLevelConfig {
	o, err := q.One(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single skillLevelConfig record from the query, and panics on error.
func (q skillLevelConfigQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *SkillLevelConfig {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single skillLevelConfig record from the query.
func (q skillLevelConfigQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SkillLevelConfig, error) {
	o := &SkillLevelConfig{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: failed to execute a one query for skill_level_configs")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all SkillLevelConfig records from the query using the global executor.
func (q skillLevelConfigQuery) AllG(ctx context.Context) (SkillLevelConfigSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// AllGP returns all SkillLevelConfig records from the query using the global executor, and panics on error.
func (q skillLevelConfigQuery) AllGP(ctx context.Context) SkillLevelConfigSlice {
	o, err := q.All(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all SkillLevelConfig records from the query, and panics on error.
func (q skillLevelConfigQuery) AllP(ctx context.Context, exec boil.ContextExecutor) SkillLevelConfigSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all SkillLevelConfig records from the query.
func (q skillLevelConfigQuery) All(ctx context.Context, exec boil.ContextExecutor) (SkillLevelConfigSlice, error) {
	var o []*SkillLevelConfig

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "game_config: failed to assign all query results to SkillLevelConfig slice")
	}

	if len(skillLevelConfigAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all SkillLevelConfig records in the query using the global executor
func (q skillLevelConfigQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// CountGP returns the count of all SkillLevelConfig records in the query using the global executor, and panics on error.
func (q skillLevelConfigQuery) CountGP(ctx context.Context) int64 {
	c, err := q.Count(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all SkillLevelConfig records in the query, and panics on error.
func (q skillLevelConfigQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all SkillLevelConfig records in the query.
func (q skillLevelConfigQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to count skill_level_configs rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q skillLevelConfigQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q skillLevelConfigQuery) ExistsGP(ctx context.Context) bool {
	e, err := q.Exists(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q skillLevelConfigQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q skillLevelConfigQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "game_config: failed to check if skill_level_configs exists")
	}

	return count > 0, nil
}

// Skill pointed to by the foreign key.
func (o *SkillLevelConfig) Skill(mods ...qm.QueryMod) skillQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SkillID),
	}

	queryMods = append(queryMods, mods...)

	return Skills(queryMods...)
}

// LoadSkill allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (skillLevelConfigL) LoadSkill(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSkillLevelConfig interface{}, mods queries.Applicator) error {
	var slice []*SkillLevelConfig
	var object *SkillLevelConfig

	if singular {
		var ok bool
		object, ok = maybeSkillLevelConfig.(*SkillLevelConfig)
		if !ok {
			object = new(SkillLevelConfig)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSkillLevelConfig)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSkillLevelConfig))
			}
		}
	} else {
		s, ok := maybeSkillLevelConfig.(*[]*SkillLevelConfig)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSkillLevelConfig)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSkillLevelConfig))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &skillLevelConfigR{}
		}
		args[object.SkillID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &skillLevelConfigR{}
			}

			args[obj.SkillID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_config.skills`),
		qm.WhereIn(`game_config.skills.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`game_config.skills.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Skill")
	}

	var resultSlice []*Skill
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Skill")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for skills")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for skills")
	}

	if len(skillAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Skill = foreign
		if foreign.R == nil {
			foreign.R = &skillR{}
		}
		foreign.R.SkillLevelConfigs = append(foreign.R.SkillLevelConfigs, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SkillID == foreign.ID {
				local.R.Skill = foreign
				if foreign.R == nil {
					foreign.R = &skillR{}
				}
				foreign.R.SkillLevelConfigs = append(foreign.R.SkillLevelConfigs, local)
				break
			}
		}
	}

	return nil
}

// SetSkillG of the skillLevelConfig to the related item.
// Sets o.R.Skill to related.
// Adds o to related.R.SkillLevelConfigs.
// Uses the global database handle.
func (o *SkillLevelConfig) SetSkillG(ctx context.Context, insert bool, related *Skill) error {
	return o.SetSkill(ctx, boil.GetContextDB(), insert, related)
}

// SetSkillP of the skillLevelConfig to the related item.
// Sets o.R.Skill to related.
// Adds o to related.R.SkillLevelConfigs.
// Panics on error.
func (o *SkillLevelConfig) SetSkillP(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Skill) {
	if err := o.SetSkill(ctx, exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetSkillGP of the skillLevelConfig to the related item.
// Sets o.R.Skill to related.
// Adds o to related.R.SkillLevelConfigs.
// Uses the global database handle and panics on error.
func (o *SkillLevelConfig) SetSkillGP(ctx context.Context, insert bool, related *Skill) {
	if err := o.SetSkill(ctx, boil.GetContextDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetSkill of the skillLevelConfig to the related item.
// Sets o.R.Skill to related.
// Adds o to related.R.SkillLevelConfigs.
func (o *SkillLevelConfig) SetSkill(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Skill) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_config\".\"skill_level_configs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"skill_id"}),
		strmangle.WhereClause("\"", "\"", 2, skillLevelConfigPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SkillID = related.ID
	if o.R == nil {
		o.R = &skillLevelConfigR{
			Skill: related,
		}
	} else {
		o.R.Skill = related
	}

	if related.R == nil {
		related.R = &skillR{
			SkillLevelConfigs: SkillLevelConfigSlice{o},
		}
	} else {
		related.R.SkillLevelConfigs = append(related.R.SkillLevelConfigs, o)
	}

	return nil
}

// SkillLevelConfigs retrieves all the records using an executor.
func SkillLevelConfigs(mods ...qm.QueryMod) skillLevelConfigQuery {
	mods = append(mods, qm.From("\"game_config\".\"skill_level_configs\""), qmhelper.WhereIsNull("\"game_config\".\"skill_level_configs\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_config\".\"skill_level_configs\".*"})
	}

	return skillLevelConfigQuery{q}
}

// FindSkillLevelConfigG retrieves a single record by ID.
func FindSkillLevelConfigG(ctx context.Context, iD string, selectCols ...string) (*SkillLevelConfig, error) {
	return FindSkillLevelConfig(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindSkillLevelConfigP retrieves a single record by ID with an executor, and panics on error.
func FindSkillLevelConfigP(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) *SkillLevelConfig {
	retobj, err := FindSkillLevelConfig(ctx, exec, iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindSkillLevelConfigGP retrieves a single record by ID, and panics on error.
func FindSkillLevelConfigGP(ctx context.Context, iD string, selectCols ...string) *SkillLevelConfig {
	retobj, err := FindSkillLevelConfig(ctx, boil.GetContextDB(), iD, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindSkillLevelConfig retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSkillLevelConfig(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*SkillLevelConfig, error) {
	skillLevelConfigObj := &SkillLevelConfig{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_config\".\"skill_level_configs\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, skillLevelConfigObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_config: unable to select from skill_level_configs")
	}

	if err = skillLevelConfigObj.doAfterSelectHooks(ctx, exec); err != nil {
		return skillLevelConfigObj, err
	}

	return skillLevelConfigObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *SkillLevelConfig) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *SkillLevelConfig) InsertP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) {
	if err := o.Insert(ctx, exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *SkillLevelConfig) InsertGP(ctx context.Context, columns boil.Columns) {
	if err := o.Insert(ctx, boil.GetContextDB(), columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SkillLevelConfig) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("game_config: no skill_level_configs provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(skillLevelConfigColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	skillLevelConfigInsertCacheMut.RLock()
	cache, cached := skillLevelConfigInsertCache[key]
	skillLevelConfigInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			skillLevelConfigAllColumns,
			skillLevelConfigColumnsWithDefault,
			skillLevelConfigColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_config\".\"skill_level_configs\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_config\".\"skill_level_configs\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "game_config: unable to insert into skill_level_configs")
	}

	if !cached {
		skillLevelConfigInsertCacheMut.Lock()
		skillLevelConfigInsertCache[key] = cache
		skillLevelConfigInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single SkillLevelConfig record using the global executor.
// See Update for more documentation.
func (o *SkillLevelConfig) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// UpdateP uses an executor to update the SkillLevelConfig, and panics on error.
// See Update for more documentation.
func (o *SkillLevelConfig) UpdateP(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateGP a single SkillLevelConfig record using the global executor. Panics on error.
// See Update for more documentation.
func (o *SkillLevelConfig) UpdateGP(ctx context.Context, columns boil.Columns) int64 {
	rowsAff, err := o.Update(ctx, boil.GetContextDB(), columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Update uses an executor to update the SkillLevelConfig.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SkillLevelConfig) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	skillLevelConfigUpdateCacheMut.RLock()
	cache, cached := skillLevelConfigUpdateCache[key]
	skillLevelConfigUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			skillLevelConfigAllColumns,
			skillLevelConfigPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("game_config: unable to update skill_level_configs, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_config\".\"skill_level_configs\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, skillLevelConfigPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, append(wl, skillLevelConfigPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update skill_level_configs row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by update for skill_level_configs")
	}

	if !cached {
		skillLevelConfigUpdateCacheMut.Lock()
		skillLevelConfigUpdateCache[key] = cache
		skillLevelConfigUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q skillLevelConfigQuery) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllG updates all rows with the specified column values.
func (q skillLevelConfigQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (q skillLevelConfigQuery) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := q.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values.
func (q skillLevelConfigQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all for skill_level_configs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected for skill_level_configs")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o SkillLevelConfigSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o SkillLevelConfigSlice) UpdateAllGP(ctx context.Context, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, boil.GetContextDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o SkillLevelConfigSlice) UpdateAllP(ctx context.Context, exec boil.ContextExecutor, cols M) int64 {
	rowsAff, err := o.UpdateAll(ctx, exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SkillLevelConfigSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("game_config: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), skillLevelConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_config\".\"skill_level_configs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, skillLevelConfigPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to update all in skillLevelConfig slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to retrieve rows affected all in update all skillLevelConfig")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *SkillLevelConfig) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *SkillLevelConfig) UpsertGP(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *SkillLevelConfig) UpsertP(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) {
	if err := o.Upsert(ctx, exec, updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SkillLevelConfig) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("game_config: no skill_level_configs provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(skillLevelConfigColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	skillLevelConfigUpsertCacheMut.RLock()
	cache, cached := skillLevelConfigUpsertCache[key]
	skillLevelConfigUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			skillLevelConfigAllColumns,
			skillLevelConfigColumnsWithDefault,
			skillLevelConfigColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			skillLevelConfigAllColumns,
			skillLevelConfigPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("game_config: unable to upsert skill_level_configs, could not build update column list")
		}

		ret := strmangle.SetComplement(skillLevelConfigAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(skillLevelConfigPrimaryKeyColumns) == 0 {
				return errors.New("game_config: unable to upsert skill_level_configs, could not build conflict column list")
			}

			conflict = make([]string, len(skillLevelConfigPrimaryKeyColumns))
			copy(conflict, skillLevelConfigPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_config\".\"skill_level_configs\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "game_config: unable to upsert skill_level_configs")
	}

	if !cached {
		skillLevelConfigUpsertCacheMut.Lock()
		skillLevelConfigUpsertCache[key] = cache
		skillLevelConfigUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single SkillLevelConfig record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *SkillLevelConfig) DeleteG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteP deletes a single SkillLevelConfig record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *SkillLevelConfig) DeleteP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteGP deletes a single SkillLevelConfig record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *SkillLevelConfig) DeleteGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.Delete(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// Delete deletes a single SkillLevelConfig record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SkillLevelConfig) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("game_config: no SkillLevelConfig provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), skillLevelConfigPrimaryKeyMapping)
		sql = "DELETE FROM \"game_config\".\"skill_level_configs\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"skill_level_configs\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(skillLevelConfigType, skillLevelConfigMapping, append(wl, skillLevelConfigPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete from skill_level_configs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by delete for skill_level_configs")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q skillLevelConfigQuery) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows, and panics on error.
func (q skillLevelConfigQuery) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows, and panics on error.
func (q skillLevelConfigQuery) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all matching rows.
func (q skillLevelConfigQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("game_config: no skillLevelConfigQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from skill_level_configs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for skill_level_configs")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o SkillLevelConfigSlice) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o SkillLevelConfigSlice) DeleteAllP(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, exec, hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o SkillLevelConfigSlice) DeleteAllGP(ctx context.Context, hardDelete bool) int64 {
	rowsAff, err := o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return rowsAff
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SkillLevelConfigSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(skillLevelConfigBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), skillLevelConfigPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"game_config\".\"skill_level_configs\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, skillLevelConfigPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), skillLevelConfigPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_config\".\"skill_level_configs\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, skillLevelConfigPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "game_config: unable to delete all from skillLevelConfig slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "game_config: failed to get rows affected by deleteall for skill_level_configs")
	}

	if len(skillLevelConfigAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *SkillLevelConfig) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: no SkillLevelConfig provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *SkillLevelConfig) ReloadP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.Reload(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadGP refetches the object from the database and panics on error.
func (o *SkillLevelConfig) ReloadGP(ctx context.Context) {
	if err := o.Reload(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SkillLevelConfig) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSkillLevelConfig(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SkillLevelConfigSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("game_config: empty SkillLevelConfigSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *SkillLevelConfigSlice) ReloadAllP(ctx context.Context, exec boil.ContextExecutor) {
	if err := o.ReloadAll(ctx, exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *SkillLevelConfigSlice) ReloadAllGP(ctx context.Context) {
	if err := o.ReloadAll(ctx, boil.GetContextDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SkillLevelConfigSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SkillLevelConfigSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), skillLevelConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_config\".\"skill_level_configs\".* FROM \"game_config\".\"skill_level_configs\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, skillLevelConfigPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "game_config: unable to reload all in SkillLevelConfigSlice")
	}

	*o = slice

	return nil
}

// SkillLevelConfigExistsG checks if the SkillLevelConfig row exists.
func SkillLevelConfigExistsG(ctx context.Context, iD string) (bool, error) {
	return SkillLevelConfigExists(ctx, boil.GetContextDB(), iD)
}

// SkillLevelConfigExistsP checks if the SkillLevelConfig row exists. Panics on error.
func SkillLevelConfigExistsP(ctx context.Context, exec boil.ContextExecutor, iD string) bool {
	e, err := SkillLevelConfigExists(ctx, exec, iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// SkillLevelConfigExistsGP checks if the SkillLevelConfig row exists. Panics on error.
func SkillLevelConfigExistsGP(ctx context.Context, iD string) bool {
	e, err := SkillLevelConfigExists(ctx, boil.GetContextDB(), iD)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// SkillLevelConfigExists checks if the SkillLevelConfig row exists.
func SkillLevelConfigExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_config\".\"skill_level_configs\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "game_config: unable to check if skill_level_configs exists")
	}

	return exists, nil
}

// Exists checks if the SkillLevelConfig row exists.
func (o *SkillLevelConfig) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return SkillLevelConfigExists(ctx, exec, o.ID)
}
