// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package game_runtime

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// HeroComputedAttribute is an object representing the database table.
type HeroComputedAttribute struct {
	HeroID          null.String       `boil:"hero_id" json:"hero_id,omitempty" toml:"hero_id" yaml:"hero_id,omitempty"`
	AttributeTypeID null.String       `boil:"attribute_type_id" json:"attribute_type_id,omitempty" toml:"attribute_type_id" yaml:"attribute_type_id,omitempty"`
	AttributeCode   null.String       `boil:"attribute_code" json:"attribute_code,omitempty" toml:"attribute_code" yaml:"attribute_code,omitempty"`
	AttributeName   null.String       `boil:"attribute_name" json:"attribute_name,omitempty" toml:"attribute_name" yaml:"attribute_name,omitempty"`
	BaseValue       null.Int          `boil:"base_value" json:"base_value,omitempty" toml:"base_value" yaml:"base_value,omitempty"`
	ClassBonus      types.NullDecimal `boil:"class_bonus" json:"class_bonus,omitempty" toml:"class_bonus" yaml:"class_bonus,omitempty"`
	FinalValue      types.NullDecimal `boil:"final_value" json:"final_value,omitempty" toml:"final_value" yaml:"final_value,omitempty"`
}

var HeroComputedAttributeColumns = struct {
	HeroID          string
	AttributeTypeID string
	AttributeCode   string
	AttributeName   string
	BaseValue       string
	ClassBonus      string
	FinalValue      string
}{
	HeroID:          "hero_id",
	AttributeTypeID: "attribute_type_id",
	AttributeCode:   "attribute_code",
	AttributeName:   "attribute_name",
	BaseValue:       "base_value",
	ClassBonus:      "class_bonus",
	FinalValue:      "final_value",
}

var HeroComputedAttributeTableColumns = struct {
	HeroID          string
	AttributeTypeID string
	AttributeCode   string
	AttributeName   string
	BaseValue       string
	ClassBonus      string
	FinalValue      string
}{
	HeroID:          "hero_computed_attributes.hero_id",
	AttributeTypeID: "hero_computed_attributes.attribute_type_id",
	AttributeCode:   "hero_computed_attributes.attribute_code",
	AttributeName:   "hero_computed_attributes.attribute_name",
	BaseValue:       "hero_computed_attributes.base_value",
	ClassBonus:      "hero_computed_attributes.class_bonus",
	FinalValue:      "hero_computed_attributes.final_value",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var HeroComputedAttributeWhere = struct {
	HeroID          whereHelpernull_String
	AttributeTypeID whereHelpernull_String
	AttributeCode   whereHelpernull_String
	AttributeName   whereHelpernull_String
	BaseValue       whereHelpernull_Int
	ClassBonus      whereHelpertypes_NullDecimal
	FinalValue      whereHelpertypes_NullDecimal
}{
	HeroID:          whereHelpernull_String{field: "\"game_runtime\".\"hero_computed_attributes\".\"hero_id\""},
	AttributeTypeID: whereHelpernull_String{field: "\"game_runtime\".\"hero_computed_attributes\".\"attribute_type_id\""},
	AttributeCode:   whereHelpernull_String{field: "\"game_runtime\".\"hero_computed_attributes\".\"attribute_code\""},
	AttributeName:   whereHelpernull_String{field: "\"game_runtime\".\"hero_computed_attributes\".\"attribute_name\""},
	BaseValue:       whereHelpernull_Int{field: "\"game_runtime\".\"hero_computed_attributes\".\"base_value\""},
	ClassBonus:      whereHelpertypes_NullDecimal{field: "\"game_runtime\".\"hero_computed_attributes\".\"class_bonus\""},
	FinalValue:      whereHelpertypes_NullDecimal{field: "\"game_runtime\".\"hero_computed_attributes\".\"final_value\""},
}

var (
	heroComputedAttributeAllColumns            = []string{"hero_id", "attribute_type_id", "attribute_code", "attribute_name", "base_value", "class_bonus", "final_value"}
	heroComputedAttributeColumnsWithoutDefault = []string{}
	heroComputedAttributeColumnsWithDefault    = []string{"hero_id", "attribute_type_id", "attribute_code", "attribute_name", "base_value", "class_bonus", "final_value"}
	heroComputedAttributePrimaryKeyColumns     = []string{}
	heroComputedAttributeGeneratedColumns      = []string{}
)

type (
	// HeroComputedAttributeSlice is an alias for a slice of pointers to HeroComputedAttribute.
	// This should almost always be used instead of []HeroComputedAttribute.
	HeroComputedAttributeSlice []*HeroComputedAttribute
	// HeroComputedAttributeHook is the signature for custom HeroComputedAttribute hook methods
	HeroComputedAttributeHook func(context.Context, boil.ContextExecutor, *HeroComputedAttribute) error

	heroComputedAttributeQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	heroComputedAttributeType           = reflect.TypeOf(&HeroComputedAttribute{})
	heroComputedAttributeMapping        = queries.MakeStructMapping(heroComputedAttributeType)
	heroComputedAttributeInsertCacheMut sync.RWMutex
	heroComputedAttributeInsertCache    = make(map[string]insertCache)
	heroComputedAttributeUpdateCacheMut sync.RWMutex
	heroComputedAttributeUpdateCache    = make(map[string]updateCache)
	heroComputedAttributeUpsertCacheMut sync.RWMutex
	heroComputedAttributeUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var heroComputedAttributeAfterSelectMu sync.Mutex
var heroComputedAttributeAfterSelectHooks []HeroComputedAttributeHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *HeroComputedAttribute) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range heroComputedAttributeAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddHeroComputedAttributeHook registers your hook function for all future operations.
func AddHeroComputedAttributeHook(hookPoint boil.HookPoint, heroComputedAttributeHook HeroComputedAttributeHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		heroComputedAttributeAfterSelectMu.Lock()
		heroComputedAttributeAfterSelectHooks = append(heroComputedAttributeAfterSelectHooks, heroComputedAttributeHook)
		heroComputedAttributeAfterSelectMu.Unlock()
	}
}

// OneG returns a single heroComputedAttribute record from the query using the global executor.
func (q heroComputedAttributeQuery) OneG(ctx context.Context) (*HeroComputedAttribute, error) {
	return q.One(ctx, boil.GetContextDB())
}

// OneGP returns a single heroComputedAttribute record from the query using the global executor, and panics on error.
func (q heroComputedAttributeQuery) OneGP(ctx context.Context) *HeroComputedAttribute {
	o, err := q.One(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single heroComputedAttribute record from the query, and panics on error.
func (q heroComputedAttributeQuery) OneP(ctx context.Context, exec boil.ContextExecutor) *HeroComputedAttribute {
	o, err := q.One(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single heroComputedAttribute record from the query.
func (q heroComputedAttributeQuery) One(ctx context.Context, exec boil.ContextExecutor) (*HeroComputedAttribute, error) {
	o := &HeroComputedAttribute{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "game_runtime: failed to execute a one query for hero_computed_attributes")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all HeroComputedAttribute records from the query using the global executor.
func (q heroComputedAttributeQuery) AllG(ctx context.Context) (HeroComputedAttributeSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// AllGP returns all HeroComputedAttribute records from the query using the global executor, and panics on error.
func (q heroComputedAttributeQuery) AllGP(ctx context.Context) HeroComputedAttributeSlice {
	o, err := q.All(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all HeroComputedAttribute records from the query, and panics on error.
func (q heroComputedAttributeQuery) AllP(ctx context.Context, exec boil.ContextExecutor) HeroComputedAttributeSlice {
	o, err := q.All(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all HeroComputedAttribute records from the query.
func (q heroComputedAttributeQuery) All(ctx context.Context, exec boil.ContextExecutor) (HeroComputedAttributeSlice, error) {
	var o []*HeroComputedAttribute

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "game_runtime: failed to assign all query results to HeroComputedAttribute slice")
	}

	if len(heroComputedAttributeAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all HeroComputedAttribute records in the query using the global executor
func (q heroComputedAttributeQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// CountGP returns the count of all HeroComputedAttribute records in the query using the global executor, and panics on error.
func (q heroComputedAttributeQuery) CountGP(ctx context.Context) int64 {
	c, err := q.Count(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all HeroComputedAttribute records in the query, and panics on error.
func (q heroComputedAttributeQuery) CountP(ctx context.Context, exec boil.ContextExecutor) int64 {
	c, err := q.Count(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all HeroComputedAttribute records in the query.
func (q heroComputedAttributeQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "game_runtime: failed to count hero_computed_attributes rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q heroComputedAttributeQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q heroComputedAttributeQuery) ExistsGP(ctx context.Context) bool {
	e, err := q.Exists(ctx, boil.GetContextDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q heroComputedAttributeQuery) ExistsP(ctx context.Context, exec boil.ContextExecutor) bool {
	e, err := q.Exists(ctx, exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q heroComputedAttributeQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "game_runtime: failed to check if hero_computed_attributes exists")
	}

	return count > 0, nil
}

// HeroComputedAttributes retrieves all the records using an executor.
func HeroComputedAttributes(mods ...qm.QueryMod) heroComputedAttributeQuery {
	mods = append(mods, qm.From("\"game_runtime\".\"hero_computed_attributes\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_runtime\".\"hero_computed_attributes\".*"})
	}

	return heroComputedAttributeQuery{q}
}
